<h1 id="ssf">SSF</h1>
<p>SpreadSheet Format (SSF) is a pure-JS library to format data using ECMA-376 spreadsheet format codes.</p>
<h2 id="options">Options</h2>
<p>The various API functions take an <code>opts</code> argument which control parsing. The default options are described below:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js&gt;tmp/10_opts.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="co">/* Options */</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">var</span> opts_fmt <span class="op">=</span> [</a></code></pre></div>
<p>There are two commonly-recognized date code formats: - 1900 mode (where date=0 is 1899-12-31) - 1904 mode (where date=0 is 1904-01-01)</p>
<p>The difference between the the 1900 and 1904 date modes is 1462 days. Since the 1904 date mode was only default in a few Mac variants of Excel (2011 uses 1900 mode), the default is 1900 mode. Consistent with ECMA-376 the name is <code>date1904</code>:</p>
<pre><code>  [&quot;date1904&quot;, 0],</code></pre>
<p>The default output is a text representation (no effort to capture colors). To control the output, set the <code>output</code> variable:</p>
<ul>
<li><code>text</code>: no color (default)</li>
<li><code>html</code>: html output using</li>
<li><code>ansi</code>: ansi color codes (requires <code>colors</code> module)</li>
</ul>
<pre><code>  [&quot;output&quot;, &quot;&quot;],</code></pre>
<p>These options are made available via the <code>opts</code> field:</p>
<pre><code>  [&quot;WTF&quot;, false]
];
function fixopts(o){
  for(var y = 0; y != opts_fmt.length; ++y) if(o[opts_fmt[y][0]]===undefined) o[opts_fmt[y][0]]=opts_fmt[y][1];
}
SSF.opts = opts_fmt;</code></pre>
<h2 id="conditional-format-codes">Conditional Format Codes</h2>
<p>The specification is a bit unclear here. It initially claims in §18.3.1:</p>
<blockquote>
<p>Up to four sections of format codes can be specified. The format codes, separated by semicolons, define the formats for positive numbers, negative numbers, zero values, and text, in that order.</p>
</blockquote>
<p>Semicolons can be escaped with the <code>\</code> character, so we need to split on those semicolons that aren’t prefaced by a slash or within a quoted string:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js&gt;tmp/80_split.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">split_fmt</span>(fmt) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="kw">var</span> out <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="kw">var</span> in_str <span class="op">=</span> <span class="kw">false</span><span class="op">,</span> cc<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="cf">for</span>(<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="va">fmt</span>.<span class="at">length</span><span class="op">;</span> <span class="op">++</span>i) <span class="cf">switch</span>((cc<span class="op">=</span><span class="va">fmt</span>.<span class="at">charCodeAt</span>(i))) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="cf">case</span> <span class="dv">34</span><span class="op">:</span> <span class="co">/* &#39;&quot;&#39; */</span></a>
<a class="sourceLine" id="cb5-6" title="6">      in_str <span class="op">=</span> <span class="op">!</span>in_str<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="cf">case</span> <span class="dv">95</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">42</span><span class="op">:</span> <span class="cf">case</span> <span class="dv">92</span><span class="op">:</span> <span class="co">/* &#39;_&#39; &#39;*&#39; &#39;\\&#39; */</span></a>
<a class="sourceLine" id="cb5-8" title="8">      <span class="op">++</span>i<span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="cf">case</span> <span class="dv">59</span><span class="op">:</span> <span class="co">/* &#39;;&#39; */</span></a>
<a class="sourceLine" id="cb5-10" title="10">      out[<span class="va">out</span>.<span class="at">length</span>] <span class="op">=</span> <span class="va">fmt</span>.<span class="at">substr</span>(j<span class="op">,</span>i<span class="op">-</span>j)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-11" title="11">      j <span class="op">=</span> i<span class="op">+</span><span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb5-13" title="13">  out[<span class="va">out</span>.<span class="at">length</span>] <span class="op">=</span> <span class="va">fmt</span>.<span class="at">substr</span>(j)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-14" title="14">  <span class="cf">if</span>(in_str <span class="op">===</span> <span class="kw">true</span>) <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;Format |&quot;</span> <span class="op">+</span> fmt <span class="op">+</span> <span class="st">&quot;| unterminated string &quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-15" title="15">  <span class="cf">return</span> out<span class="op">;</span></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="va">SSF</span>.<span class="at">_split</span> <span class="op">=</span> split_fmt<span class="op">;</span></a></code></pre></div>
<p>But it also allows for conditional formatting:</p>
<blockquote>
<p>To set number formats that are applied only if a number meets a specified condition, enclose the condition in square brackets. The condition consists of a comparison operator and a value. Comparison operators include: <code>=</code> Equal to; <code>&gt;</code> Greater than; <code>&lt;</code> Less than; <code>&gt;=</code> Greater than or equal to, <code>&lt;=</code> Less than or equal to, and <code>&lt;&gt;</code> Not equal to.</p>
</blockquote>
<p>One problem is that Excel doesn’t support three conditionals. For example:</p>
<pre class="&gt;"><code>[Red][&lt;-25]General;[Blue][&gt;25]General;[Green][&lt;&gt;0]General;[Yellow]General</code></pre>
<p>One would expect that the format code would color all numbers that are <code>&lt; -25</code> in red, all numbers <code>&gt; 25</code> in blue, nonzero numbers between <code>-25</code> and <code>25</code> in green, and color <code>0</code> and text in yellow. Excel doesn’t do that.</p>
<p>The two-conditional case works in an “expected” way if you interpret the third clause as the case for numbers that don’t fit the first two:</p>
<pre class="&gt;"><code>[Red][&lt;-25]General;[Blue][&gt;25]General;[Green]General;[Yellow]General</code></pre>
<p>will render values below <code>-25</code> as Red, above <code>25</code> as Blue, Green for other numbers, and Yellow for text.</p>
<p>Only the text case is allowed to have the <code>@</code> text sigil. Excel interprets it as the last format.</p>
<h2 id="utility-functions">Utility Functions</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode js&gt;tmp/02_utilities.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">function</span> <span class="at">_strrev</span>(x) <span class="op">{</span> <span class="kw">var</span> o <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">,</span> i <span class="op">=</span> <span class="va">x</span>.<span class="at">length</span><span class="dv">-1</span><span class="op">;</span> <span class="cf">while</span>(i<span class="op">&gt;=</span><span class="dv">0</span>) o <span class="op">+=</span> <span class="va">x</span>.<span class="at">charAt</span>(i<span class="op">--</span>)<span class="op">;</span> <span class="cf">return</span> o<span class="op">;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="kw">function</span> <span class="at">fill</span>(c<span class="op">,</span>l) <span class="op">{</span> <span class="kw">var</span> o <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span> <span class="cf">while</span>(<span class="va">o</span>.<span class="at">length</span> <span class="op">&lt;</span> l) o<span class="op">+=</span>c<span class="op">;</span> <span class="cf">return</span> o<span class="op">;</span> <span class="op">}</span></a></code></pre></div>
<p>The next few helpers break up the general <code>pad</code> function into special cases:</p>
<pre><code>function pad0(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:fill(&#39;0&#39;,d-t.length)+t;}
function pad_(v,d){var t=&quot;&quot;+v;return t.length&gt;=d?t:fill(&#39; &#39;,d-t.length)+t;}
function rpad_(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:t+fill(&#39; &#39;,d-t.length);}
function pad0r1(v,d){var t=&quot;&quot;+Math.round(v); return t.length&gt;=d?t:fill(&#39;0&#39;,d-t.length)+t;}
function pad0r2(v,d){var t=&quot;&quot;+v; return t.length&gt;=d?t:fill(&#39;0&#39;,d-t.length)+t;}
var p2_32 = Math.pow(2,32);
function pad0r(v,d){if(v&gt;p2_32||v&lt;-p2_32) return pad0r1(v,d); var i = Math.round(v); return pad0r2(i,d); }</code></pre>
<p>Comparing against the string “general” is faster via char codes:</p>
<pre><code>function isgeneral(s, i) { return s.length &gt;= 7 + i &amp;&amp; (s.charCodeAt(i)|32) === 103 &amp;&amp; (s.charCodeAt(i+1)|32) === 101 &amp;&amp; (s.charCodeAt(i+2)|32) === 110 &amp;&amp; (s.charCodeAt(i+3)|32) === 101 &amp;&amp; (s.charCodeAt(i+4)|32) === 114 &amp;&amp; (s.charCodeAt(i+5)|32) === 97 &amp;&amp; (s.charCodeAt(i+6)|32) === 108; }</code></pre>
<h2 id="general-number-format">General Number Format</h2>
<p>The ‘general’ format for spreadsheets (identified by format code 0) is highly context-sensitive and the implementation tries to follow the format to the best of its abilities given the knowledge.</p>
<p>First: 32-bit integers in base 10 are shorter than 11 characters, so they will always be written in full:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js&gt;tmp/40_general.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">function</span> <span class="at">general_fmt_int</span>(v<span class="op">,</span> opts) <span class="op">{</span> <span class="cf">return</span> <span class="st">&quot;&quot;</span><span class="op">+</span>v<span class="op">;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="va">SSF</span>.<span class="at">_general_int</span> <span class="op">=</span> general_fmt_int<span class="op">;</span></a></code></pre></div>
<p>Next: other numbers require some finessing:</p>
<pre><code>var general_fmt_num = (function make_general_fmt_num() {
var gnr1 = /\.(\d*[1-9])0+$/, gnr2 = /\.0*$/, gnr4 = /\.(\d*[1-9])0+/, gnr5 = /\.0*[Ee]/, gnr6 = /(E[+-])(\d)$/;
function gfn2(v) {
  var w = (v&lt;0?12:11);
  var o = gfn5(v.toFixed(12)); if(o.length &lt;= w) return o;
  o = v.toPrecision(10); if(o.length &lt;= w) return o;
  return v.toExponential(5);
}
function gfn3(v) {
  var o = v.toFixed(11).replace(gnr1,&quot;.$1&quot;);
  if(o.length &gt; (v&lt;0?12:11)) o = v.toPrecision(6);
  return o;
}
function gfn4(o) {
  for(var i = 0; i != o.length; ++i) if((o.charCodeAt(i) | 0x20) === 101) return o.replace(gnr4,&quot;.$1&quot;).replace(gnr5,&quot;E&quot;).replace(&quot;e&quot;,&quot;E&quot;).replace(gnr6,&quot;$10$2&quot;);
  return o;
}
function gfn5(o) {
  //for(var i = 0; i != o.length; ++i) if(o.charCodeAt(i) === 46) return o.replace(gnr2,&quot;&quot;).replace(gnr1,&quot;.$1&quot;);
  //return o;
  return o.indexOf(&quot;.&quot;) &gt; -1 ? o.replace(gnr2,&quot;&quot;).replace(gnr1,&quot;.$1&quot;) : o;
}
return function general_fmt_num(v, opts) {
  var V = Math.floor(Math.log(Math.abs(v))*Math.LOG10E), o;
  if(V &gt;= -4 &amp;&amp; V &lt;= -1) o = v.toPrecision(10+V);
  else if(Math.abs(V) &lt;= 9) o = gfn2(v);
  else if(V === 10) o = v.toFixed(10).substr(0,12);
  else o = gfn3(v);
  return gfn5(gfn4(o));
};})();
SSF._general_num = general_fmt_num;</code></pre>
<p>Finally</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js&gt;tmp/40_general.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">function</span> <span class="at">general_fmt</span>(v<span class="op">,</span> opts) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="cf">switch</span>(<span class="kw">typeof</span> v) <span class="op">{</span></a></code></pre></div>
<p>For strings, just return the text as-is:</p>
<pre><code>    case &#39;string&#39;: return v;</code></pre>
<p>Booleans are serialized in upper case:</p>
<pre><code>    case &#39;boolean&#39;: return v ? &quot;TRUE&quot; : &quot;FALSE&quot;;</code></pre>
<p>For numbers, call the relevant function (int or num) based on the value:</p>
<pre><code>    case &#39;number&#39;: return (v|0) === v ? general_fmt_int(v, opts) : general_fmt_num(v, opts);
  }</code></pre>
<p>Anything else is bad:</p>
<pre><code>  throw new Error(&quot;unsupported value in General format: &quot; + v);
}
SSF._general = general_fmt;</code></pre>
<h2 id="implied-number-formats">Implied Number Formats</h2>
<p>These are the commonly-used formats that have a special implied code. None of the international formats are included here.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js&gt;tmp/20_consts.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">var</span> table_fmt <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="dv">0</span><span class="op">:</span>  <span class="st">&#39;General&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="dv">1</span><span class="op">:</span>  <span class="st">&#39;0&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-4" title="4">  <span class="dv">2</span><span class="op">:</span>  <span class="st">&#39;0.00&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-5" title="5">  <span class="dv">3</span><span class="op">:</span>  <span class="st">&#39;#,##0&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-6" title="6">  <span class="dv">4</span><span class="op">:</span>  <span class="st">&#39;#,##0.00&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-7" title="7">  <span class="dv">9</span><span class="op">:</span>  <span class="st">&#39;0%&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-8" title="8">  <span class="dv">10</span><span class="op">:</span> <span class="st">&#39;0.00%&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-9" title="9">  <span class="dv">11</span><span class="op">:</span> <span class="st">&#39;0.00E+00&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-10" title="10">  <span class="dv">12</span><span class="op">:</span> <span class="st">&#39;# ?/?&#39;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb18-11" title="11">  <span class="dv">13</span><span class="op">:</span> <span class="st">&#39;# ??/??&#39;</span><span class="op">,</span></a></code></pre></div>
<p>Now Excel and other formats treat code 14 as <code>m/d/yy</code> (with slashes). Given that the spec gives no internationalization considerations, erring on the side of the applications makes sense here:</p>
<pre><code>  14: &#39;m/d/yy&#39;,
  15: &#39;d-mmm-yy&#39;,
  16: &#39;d-mmm&#39;,
  17: &#39;mmm-yy&#39;,
  18: &#39;h:mm AM/PM&#39;,
  19: &#39;h:mm:ss AM/PM&#39;,
  20: &#39;h:mm&#39;,
  21: &#39;h:mm:ss&#39;,
  22: &#39;m/d/yy h:mm&#39;,
  37: &#39;#,##0 ;(#,##0)&#39;,
  38: &#39;#,##0 ;[Red](#,##0)&#39;,
  39: &#39;#,##0.00;(#,##0.00)&#39;,
  40: &#39;#,##0.00;[Red](#,##0.00)&#39;,
  45: &#39;mm:ss&#39;,
  46: &#39;[h]:mm:ss&#39;,
  47: &#39;mmss.0&#39;,
  48: &#39;##0.0E+0&#39;,
  49: &#39;@&#39;,</code></pre>
<p>There are special implicit format codes identified in [ECMA-376] 18.8.30. Assuming zh-tw is the default:</p>
<pre><code>  56: &#39;&quot;上午/下午 &quot;hh&quot;時&quot;mm&quot;分&quot;ss&quot;秒 &quot;&#39;,</code></pre>
<p>some writers erroneously emit 65535 for general:</p>
<pre><code>  65535: &#39;General&#39;
};</code></pre>
<h2 id="dates-and-time">Dates and Time</h2>
<p>The code <code>ddd</code> displays short day-of-week and <code>dddd</code> shows long day-of-week:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js&gt;tmp/20_consts.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">var</span> days <span class="op">=</span> [</a>
<a class="sourceLine" id="cb22-2" title="2">  [<span class="st">&#39;Sun&#39;</span><span class="op">,</span> <span class="st">&#39;Sunday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-3" title="3">  [<span class="st">&#39;Mon&#39;</span><span class="op">,</span> <span class="st">&#39;Monday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-4" title="4">  [<span class="st">&#39;Tue&#39;</span><span class="op">,</span> <span class="st">&#39;Tuesday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-5" title="5">  [<span class="st">&#39;Wed&#39;</span><span class="op">,</span> <span class="st">&#39;Wednesday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-6" title="6">  [<span class="st">&#39;Thu&#39;</span><span class="op">,</span> <span class="st">&#39;Thursday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-7" title="7">  [<span class="st">&#39;Fri&#39;</span><span class="op">,</span> <span class="st">&#39;Friday&#39;</span>]<span class="op">,</span></a>
<a class="sourceLine" id="cb22-8" title="8">  [<span class="st">&#39;Sat&#39;</span><span class="op">,</span> <span class="st">&#39;Saturday&#39;</span>]</a>
<a class="sourceLine" id="cb22-9" title="9">]<span class="op">;</span></a></code></pre></div>
<p><code>mmm</code> shows short month, <code>mmmm</code> shows long month, and <code>mmmmm</code> shows one char:</p>
<pre><code>var months = [
  [&#39;J&#39;, &#39;Jan&#39;, &#39;January&#39;],
  [&#39;F&#39;, &#39;Feb&#39;, &#39;February&#39;],
  [&#39;M&#39;, &#39;Mar&#39;, &#39;March&#39;],
  [&#39;A&#39;, &#39;Apr&#39;, &#39;April&#39;],
  [&#39;M&#39;, &#39;May&#39;, &#39;May&#39;],
  [&#39;J&#39;, &#39;Jun&#39;, &#39;June&#39;],
  [&#39;J&#39;, &#39;Jul&#39;, &#39;July&#39;],
  [&#39;A&#39;, &#39;Aug&#39;, &#39;August&#39;],
  [&#39;S&#39;, &#39;Sep&#39;, &#39;September&#39;],
  [&#39;O&#39;, &#39;Oct&#39;, &#39;October&#39;],
  [&#39;N&#39;, &#39;Nov&#39;, &#39;November&#39;],
  [&#39;D&#39;, &#39;Dec&#39;, &#39;December&#39;]
];</code></pre>
<h2 id="parsing-date-and-time-codes">Parsing Date and Time Codes</h2>
<p>Most spreadsheet formats store dates and times as floating point numbers (where the integer part is a day code based on a format and the fractional part is the portion of a 24 hour day).</p>
<p>Excel supports the alternative Hijri calendar (indicated with <code>b2</code>):</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode js&gt;tmp/50_date.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">function</span> <span class="at">parse_date_code</span>(v<span class="op">,</span>opts<span class="op">,</span>b2) <span class="op">{</span></a></code></pre></div>
<p>Date codes beyond 12/31/9999 are invalid:</p>
<pre><code>  if(v &gt; 2958465 || v &lt; 0) return null;</code></pre>
<p>Now we can parse!</p>
<pre><code>  var date = (v|0), time = Math.floor(86400 * (v - date)), dow=0;
  var dout=[];
  var out={D:date, T:time, u:86400*(v-date)-time,y:0,m:0,d:0,H:0,M:0,S:0,q:0};
  if(Math.abs(out.u) &lt; 1e-6) out.u = 0;
  fixopts(opts != null ? opts : (opts=[]));</code></pre>
<p>Excel help actually recommends treating the 1904 date codes as 1900 date codes shifted by 1462 days.</p>
<pre><code>  if(opts.date1904) date += 1462;</code></pre>
<p>Due to floating point issues, correct for subseconds:</p>
<pre><code>  if(out.u &gt; 0.999) {
    out.u = 0;
    if(++time == 86400) { time = 0; ++date; }
  }</code></pre>
<p>Due to a bug in Lotus 1-2-3 which was propagated by Excel and other variants, the year 1900 is recognized as a leap year. JS has no way of representing that abomination as a <code>Date</code>, so the easiest way is to store the data as a tuple.</p>
<p>February 29, 1900 (date <code>60</code>) is recognized as a Wednesday. Date <code>0</code> is treated as January 0, 1900 rather than December 31, 1899.</p>
<pre><code>  if(date === 60) {dout = b2 ? [1317,10,29] : [1900,2,29]; dow=3;}
  else if(date === 0) {dout = b2 ? [1317,8,29] : [1900,1,0]; dow=6;}</code></pre>
<p>For the other dates, using the JS date mechanism suffices.</p>
<pre><code>  else {
    if(date &gt; 60) --date;
    /* 1 = Jan 1 1900 */
    var d = new Date(1900,0,1);
    d.setDate(d.getDate() + date - 1);
    dout = [d.getFullYear(), d.getMonth()+1,d.getDate()];
    dow = d.getDay();</code></pre>
<p>Note that Excel opted to keep the day-of-week metric consistent with the extra day. In practice, that means the days before the fake leap day are off. For example, date code <code>55</code> is “Friday, February 24, 1900” when in fact it was a Saturday. The “right” thing to do is to keep the DOW consistent and just break the fact that there are two Wednesdays in that “week”.</p>
<pre><code>    if(date &lt; 60) dow = (dow + 6) % 7;</code></pre>
<p>For the hijri calendar, the date needs to be fixed</p>
<pre><code>    if(b2) dow = fix_hijri(d, dout);
  }</code></pre>
<p>Because JS dates cannot represent the bad leap day, this returns an object:</p>
<pre><code>  out.y = dout[0]; out.m = dout[1]; out.d = dout[2];
  out.S = time % 60; time = Math.floor(time / 60);
  out.M = time % 60; time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
SSF.parse_date_code = parse_date_code;</code></pre>
<p>TODO: suitable hijri correction</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode js&gt;tmp/45_hijri.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">function</span> <span class="at">fix_hijri</span>(date<span class="op">,</span> o) <span class="op">{</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="op">}</span></a></code></pre></div>
<h2 id="evaluating-number-formats">Evaluating Number Formats</h2>
<p>The utility <code>commaify</code> adds commas to integers:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode js&gt;tmp/56_commaify.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">function</span> <span class="at">commaify</span>(s) <span class="op">{</span></a>
<a class="sourceLine" id="cb35-2" title="2">  <span class="cf">if</span>(<span class="va">s</span>.<span class="at">length</span> <span class="op">&lt;=</span> <span class="dv">3</span>) <span class="cf">return</span> s<span class="op">;</span></a>
<a class="sourceLine" id="cb35-3" title="3">  <span class="kw">var</span> j <span class="op">=</span> (<span class="va">s</span>.<span class="at">length</span> <span class="op">%</span> <span class="dv">3</span>)<span class="op">,</span> o <span class="op">=</span> <span class="va">s</span>.<span class="at">substr</span>(<span class="dv">0</span><span class="op">,</span>j)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-4" title="4">  <span class="cf">for</span>(<span class="op">;</span> j<span class="op">!=</span><span class="va">s</span>.<span class="at">length</span><span class="op">;</span> j<span class="op">+=</span><span class="dv">3</span>) o<span class="op">+=</span>(<span class="va">o</span>.<span class="at">length</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="st">&quot;,&quot;</span> : <span class="st">&quot;&quot;</span>) <span class="op">+</span> <span class="va">s</span>.<span class="at">substr</span>(j<span class="op">,</span><span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb35-5" title="5">  <span class="cf">return</span> o<span class="op">;</span></a>
<a class="sourceLine" id="cb35-6" title="6"><span class="op">}</span></a></code></pre></div>
<p><code>write_num</code> is broken into sub-functions to help with optimization:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode js&gt;tmp/57_numhead.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">var</span> write_num <span class="op">=</span> (<span class="kw">function</span> <span class="at">make_write_num</span>()<span class="op">{</span></a></code></pre></div>
<h3 id="percentages">Percentages</h3>
<p>The underlying number for the percentages should be physically shifted:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode js&gt;tmp/59_numhelp.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">var</span> pct1 <span class="op">=</span> <span class="ss">/%/g</span><span class="op">;</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="kw">function</span> <span class="at">write_num_pct</span>(type<span class="op">,</span> fmt<span class="op">,</span> val)<span class="op">{</span></a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="kw">var</span> sfmt <span class="op">=</span> <span class="va">fmt</span>.<span class="at">replace</span>(pct1<span class="op">,</span><span class="st">&quot;&quot;</span>)<span class="op">,</span> mul <span class="op">=</span> <span class="va">fmt</span>.<span class="at">length</span> <span class="op">-</span> <span class="va">sfmt</span>.<span class="at">length</span><span class="op">;</span></a>
<a class="sourceLine" id="cb37-4" title="4">  <span class="cf">return</span> <span class="at">write_num</span>(type<span class="op">,</span> sfmt<span class="op">,</span> val <span class="op">*</span> <span class="va">Math</span>.<span class="at">pow</span>(<span class="dv">10</span><span class="op">,</span><span class="dv">2</span><span class="op">*</span>mul)) <span class="op">+</span> <span class="at">fill</span>(<span class="st">&quot;%&quot;</span><span class="op">,</span>mul)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="op">}</span></a></code></pre></div>
<h3 id="trailing-commas">Trailing Commas</h3>
<p>Formats with multiple commas after the decimal point should be shifted by the appropiate multiple of 1000 (more magic):</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode js&gt;tmp/60_number.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">function</span> <span class="at">write_num_cm</span>(type<span class="op">,</span> fmt<span class="op">,</span> val)<span class="op">{</span></a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="kw">var</span> idx <span class="op">=</span> <span class="va">fmt</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb38-3" title="3">  <span class="cf">while</span>(<span class="va">fmt</span>.<span class="at">charCodeAt</span>(idx<span class="dv">-1</span>) <span class="op">===</span> <span class="dv">44</span>) <span class="op">--</span>idx<span class="op">;</span></a>
<a class="sourceLine" id="cb38-4" title="4">  <span class="cf">return</span> <span class="at">write_num</span>(type<span class="op">,</span> <span class="va">fmt</span>.<span class="at">substr</span>(<span class="dv">0</span><span class="op">,</span>idx)<span class="op">,</span> val / <span class="va">Math</span>.<span class="at">pow</span>(<span class="dv">10</span><span class="op">,</span><span class="dv">3</span><span class="op">*</span>(<span class="va">fmt</span>.<span class="at">length</span><span class="op">-</span>idx)))<span class="op">;</span></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="op">}</span></a></code></pre></div>
<h3 id="exponential">Exponential</h3>
<p>For exponents, get the exponent and mantissa and format them separately:</p>
<pre><code>function write_num_exp(fmt, val){
  var o;
  var idx = fmt.indexOf(&quot;E&quot;) - fmt.indexOf(&quot;.&quot;) - 1;</code></pre>
<p>For the special case of engineering notation, “shift” the decimal:</p>
<pre><code>  if(fmt.match(/^#+0.0E\+0$/)) {
    var period = fmt.indexOf(&quot;.&quot;); if(period === -1) period=fmt.indexOf(&#39;E&#39;);
    var ee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E)%period;
    if(ee &lt; 0) ee += period;
    o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
    if(o.indexOf(&quot;e&quot;) === -1) {</code></pre>
<p>TODO: something cleaner</p>
<pre><code>      var fakee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E);
      if(o.indexOf(&quot;.&quot;) === -1) o = o[0] + &quot;.&quot; + o.substr(1) + &quot;E+&quot; + (fakee - o.length+ee);
      else o += &quot;E+&quot; + (fakee - ee);
      while(o.substr(0,2) === &quot;0.&quot;) {
        o = o[0] + o.substr(2,period) + &quot;.&quot; + o.substr(2+period);
        o = o.replace(/^0+([1-9])/,&quot;$1&quot;).replace(/^0+\./,&quot;0.&quot;);
      }
      o = o.replace(/\+-/,&quot;-&quot;);
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + &quot;.&quot; + $3.substr(ee) + &quot;E&quot;; });
  } else o = val.toExponential(idx);
  if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + &quot;0&quot; + o[o.length-1];
  if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,&quot;e&quot;);
  return o.replace(&quot;e&quot;,&quot;E&quot;);
}</code></pre>
<h3 id="fractions">Fractions</h3>
<pre><code>var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r, aval, sign) {
  var den = parseInt(r[4]), rr = Math.round(aval * den), base = Math.floor(rr/den);
  var myn = (rr - base*den), myd = den;
  return sign + (base === 0 ? &quot;&quot; : &quot;&quot;+base) + &quot; &quot; + (myn === 0 ? fill(&quot; &quot;, r[1].length + 1 + r[4].length) : pad_(myn,r[1].length) + r[2] + &quot;/&quot; + r[3] + pad0(myd,r[4].length));
}
function write_num_f2(r, aval, sign) {
  return sign + (aval === 0 ? &quot;&quot; : &quot;&quot;+aval) + fill(&quot; &quot;, r[1].length + 2 + r[4].length);
}
var dec1 = /^#*0*\.(0+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o = &quot;&quot;, cc;
  for(var i = 0; i != str.length; ++i) switch((cc=str.charCodeAt(i))) {
    case 35: break;
    case 63: o+= &quot; &quot;; break;
    case 48: o+= &quot;0&quot;; break;
    default: o+= String.fromCharCode(cc);
  }
  return o;
}</code></pre>
<p>V8 has an annoying habit of deoptimizing round and floor</p>
<pre><code>function rnd(val, d) { var dd = Math.pow(10,d); return &quot;&quot;+(Math.round(val * dd)/dd); }
function dec(val, d) { return Math.round((val-Math.floor(val))*Math.pow(10,d)); }
function flr(val) { if(val &lt; 2147483647 &amp;&amp; val &gt; -2147483648) return &quot;&quot;+(val &gt;= 0 ? (val|0) : (val-1|0)); return &quot;&quot;+Math.floor(val); }</code></pre>
<h3 id="main-number-writing-function">Main Number Writing Function</h3>
<p>Finally the body:</p>
<pre><code>function write_num_flt(type, fmt, val) {</code></pre>
<p>For parentheses, explicitly resolve the sign issue:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode js&gt;tmp/60_number.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb45-1" title="1">  <span class="cf">if</span>(<span class="va">type</span>.<span class="at">charCodeAt</span>(<span class="dv">0</span>) <span class="op">===</span> <span class="dv">40</span> <span class="op">&amp;&amp;</span> <span class="op">!</span><span class="va">fmt</span>.<span class="at">match</span>(closeparen)) <span class="op">{</span></a>
<a class="sourceLine" id="cb45-2" title="2">    <span class="kw">var</span> ffmt <span class="op">=</span> <span class="va">fmt</span>.<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\(</span><span class="ss"> </span><span class="sc">*</span><span class="ss">/</span><span class="op">,</span><span class="st">&quot;&quot;</span>).<span class="at">replace</span>(<span class="ss">/ </span><span class="sc">\)</span><span class="ss">/</span><span class="op">,</span><span class="st">&quot;&quot;</span>).<span class="at">replace</span>(<span class="ss">/</span><span class="sc">\)</span><span class="ss">/</span><span class="op">,</span><span class="st">&quot;&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb45-3" title="3">    <span class="cf">if</span>(val <span class="op">&gt;=</span> <span class="dv">0</span>) <span class="cf">return</span> <span class="at">write_num_flt</span>(<span class="st">&#39;n&#39;</span><span class="op">,</span> ffmt<span class="op">,</span> val)<span class="op">;</span></a>
<a class="sourceLine" id="cb45-4" title="4">    <span class="cf">return</span> <span class="st">&#39;(&#39;</span> <span class="op">+</span> <span class="at">write_num_flt</span>(<span class="st">&#39;n&#39;</span><span class="op">,</span> ffmt<span class="op">,</span> <span class="op">-</span>val) <span class="op">+</span> <span class="st">&#39;)&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb45-5" title="5">  <span class="op">}</span></a></code></pre></div>
<p>Helpers are used for: - Percentage values - Trailing commas - Exponentials</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode js&gt;tmp/60_number.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb46-1" title="1">  <span class="cf">if</span>(<span class="va">fmt</span>.<span class="at">charCodeAt</span>(<span class="va">fmt</span>.<span class="at">length</span> <span class="op">-</span> <span class="dv">1</span>) <span class="op">===</span> <span class="dv">44</span>) <span class="cf">return</span> <span class="at">write_num_cm</span>(type<span class="op">,</span> fmt<span class="op">,</span> val)<span class="op">;</span></a>
<a class="sourceLine" id="cb46-2" title="2">  <span class="cf">if</span>(<span class="va">fmt</span>.<span class="at">indexOf</span>(<span class="st">&#39;%&#39;</span>) <span class="op">!==</span> <span class="dv">-1</span>) <span class="cf">return</span> <span class="at">write_num_pct</span>(type<span class="op">,</span> fmt<span class="op">,</span> val)<span class="op">;</span></a>
<a class="sourceLine" id="cb46-3" title="3">  <span class="cf">if</span>(<span class="va">fmt</span>.<span class="at">indexOf</span>(<span class="st">&#39;E&#39;</span>) <span class="op">!==</span> <span class="dv">-1</span>) <span class="cf">return</span> <span class="at">write_num_exp</span>(fmt<span class="op">,</span> val)<span class="op">;</span></a></code></pre></div>
<p>TODO: localize the currency:</p>
<pre><code>  if(fmt.charCodeAt(0) === 36) return &quot;$&quot;+write_num_flt(type,fmt.substr(fmt[1]==&#39; &#39;?2:1),val);</code></pre>
<p>Some simple cases should be resolved first:</p>
<pre><code>  var o, oo;
  var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? &quot;-&quot; : &quot;&quot;;
  if(fmt.match(/^00+$/)) return sign + pad0r(aval,fmt.length);
  if(fmt.match(/^[#?]+$/)) {
    o = pad0r(val,0); if(o === &quot;0&quot;) o = &quot;&quot;;
    return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
  }</code></pre>
<p>Fractions with known denominator are resolved by rounding:</p>
<pre><code>  if((r = fmt.match(frac1)) !== null) return write_num_f1(r, aval, sign);</code></pre>
<p>A few special general cases can be handled in a very dumb manner:</p>
<pre><code>  if(fmt.match(/^#+0+$/) !== null) return sign + pad0r(aval,fmt.length - fmt.indexOf(&quot;0&quot;));
  if((r = fmt.match(dec1)) !== null) {
    o = rnd(val, r[1].length).replace(/^([^\.]+)$/,&quot;$1.&quot;+r[1]).replace(/\.$/,&quot;.&quot;+r[1]).replace(/\.(\d*)$/,function($$, $1) { return &quot;.&quot; + $1 + fill(&quot;0&quot;, r[1].length-$1.length); });
    return fmt.indexOf(&quot;0.&quot;) !== -1 ? o : o.replace(/^0\./,&quot;.&quot;);
  }</code></pre>
<p>The next few simplifications ignore leading optional sigils (<code>#</code>):</p>
<pre><code>  fmt = fmt.replace(/^#+([0.])/, &quot;$1&quot;);
  if((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
    return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/,&quot;.$1&quot;).replace(/^(-?\d*)$/,&quot;$1.&quot;).replace(/^0\./,r[1].length?&quot;0.&quot;:&quot;.&quot;);
  }
  if((r = fmt.match(/^#,##0(\.?)$/)) !== null) return sign + commaify(pad0r(aval,0));
  if((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
    return val &lt; 0 ? &quot;-&quot; + write_num_flt(type, fmt, -val) : commaify(&quot;&quot;+(Math.floor(val))) + &quot;.&quot; + pad0(dec(val, r[1].length),r[1].length);
  }
  if((r = fmt.match(/^#,#*,#0/)) !== null) return write_num_flt(type,fmt.replace(/^#,#*,/,&quot;&quot;),val);</code></pre>
<p>The <code>Zip Code + 4</code> format needs to treat an interstitial hyphen as a character:</p>
<pre><code>  if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
    o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g,&quot;&quot;), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g,&quot;&quot;)).replace(/[0#]/g,function(x){return ri&lt;o.length?o[ri++]:x===&#39;0&#39;?&#39;0&#39;:&quot;&quot;;}));
  }</code></pre>
<p>There’s a better way to generalize the phone number and other formats in terms of first drawing the digits, but this selection allows for more nuance:</p>
<pre><code>  if(fmt.match(phone) !== null) {
    o = write_num_flt(type, &quot;##########&quot;, val);
    return &quot;(&quot; + o.substr(0,3) + &quot;) &quot; + o.substr(3, 3) + &quot;-&quot; + o.substr(6);
  }</code></pre>
<p>The frac helper function is used for fraction formats (defined below).</p>
<pre><code>  var oa = &quot;&quot;;
  if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
    ri = Math.min(r[4].length,7);
    ff = frac(aval, Math.pow(10,ri)-1, false);
    o = &quot;&quot; + sign;
    oa = write_num(&quot;n&quot;, r[1], ff[1]);
    if(oa[oa.length-1] == &quot; &quot;) oa = oa.substr(0,oa.length-1) + &quot;0&quot;;
    o += oa + r[2] + &quot;/&quot; + r[3];
    oa = rpad_(ff[2],ri);
    if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
    o += oa;
    return o;
  }
  if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
    ri = Math.min(Math.max(r[1].length, r[4].length),7);
    ff = frac(aval, Math.pow(10,ri)-1, true);
    return sign + (ff[0]||(ff[1] ? &quot;&quot; : &quot;0&quot;)) + &quot; &quot; + (ff[1] ? pad_(ff[1],ri) + r[2] + &quot;/&quot; + r[3] + rpad_(ff[2],ri): fill(&quot; &quot;, 2*ri+1 + r[2].length + r[3].length));
  }</code></pre>
<p>The general class <code>/^[#0?]+$/</code> treats the ‘0’ as literal, ‘#’ as noop, ‘?’ as space:</p>
<pre><code>  if((r = fmt.match(/^[#0?]+$/)) !== null) {
    o = pad0r(val, 0);
    if(fmt.length &lt;= o.length) return o;
    return hashq(fmt.substr(0,fmt.length-o.length)) + o;
  }
  if((r = fmt.match(/^([#0?]+)\.([#0]+)$/)) !== null) {
    o = &quot;&quot; + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,&quot;$1&quot;);
    ri = o.indexOf(&quot;.&quot;);
    var lres = fmt.indexOf(&quot;.&quot;) - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
  }</code></pre>
<p>The default cases are hard-coded. TODO: actually parse them</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode js&gt;tmp/60_number.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb56-1" title="1">  <span class="cf">if</span>((r <span class="op">=</span> <span class="va">fmt</span>.<span class="at">match</span>(<span class="ss">/</span><span class="sc">^</span><span class="ss">00,000</span><span class="sc">\.([#0]*</span><span class="ss">0</span><span class="sc">)$</span><span class="ss">/</span>)) <span class="op">!==</span> <span class="kw">null</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-2" title="2">    ri <span class="op">=</span> <span class="at">dec</span>(val<span class="op">,</span> r[<span class="dv">1</span>].<span class="at">length</span>)<span class="op">;</span></a></code></pre></div>
<p>Note that this is technically incorrect</p>
<pre><code>    return val &lt; 0 ? &quot;-&quot; + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/,&quot;0$&amp;&quot;).replace(/^\d*$/,function($$) { return &quot;00,&quot; + ($$.length &lt; 3 ? pad0(0,3-$$.length) : &quot;&quot;) + $$; }) + &quot;.&quot; + pad0(ri,r[1].length);
  }
  switch(fmt) {
    case &quot;#,###&quot;: var x = commaify(pad0r(aval,0)); return x !== &quot;0&quot; ? sign + x : &quot;&quot;;</code></pre>
<p>For now, the default case is an error:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode js&gt;tmp/60_number.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb58-1" title="1">    <span class="im">default</span><span class="op">:</span></a>
<a class="sourceLine" id="cb58-2" title="2">  }</a>
<a class="sourceLine" id="cb58-3" title="3">  <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;unsupported format |&quot;</span> <span class="op">+</span> fmt <span class="op">+</span> <span class="st">&quot;|&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb58-4" title="4">}</a></code></pre></div>
<h3 id="integer-optimizations">Integer Optimizations</h3>
<pre><code>function write_num_cm2(type, fmt, val){
  var idx = fmt.length - 1;
  while(fmt.charCodeAt(idx-1) === 44) --idx;
  return write_num(type, fmt.substr(0,idx), val / Math.pow(10,3*(fmt.length-idx)));
}
function write_num_pct2(type, fmt, val){
  var sfmt = fmt.replace(pct1,&quot;&quot;), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10,2*mul)) + fill(&quot;%&quot;,mul);
}
function write_num_exp2(fmt, val){
  var o;
  var idx = fmt.indexOf(&quot;E&quot;) - fmt.indexOf(&quot;.&quot;) - 1;
  if(fmt.match(/^#+0.0E\+0$/)) {
    var period = fmt.indexOf(&quot;.&quot;); if(period === -1) period=fmt.indexOf(&#39;E&#39;);
    var ee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E)%period;
    if(ee &lt; 0) ee += period;
    o = (val/Math.pow(10,ee)).toPrecision(idx+1+(period+ee)%period);
    if(!o.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(Math.abs(val))*Math.LOG10E);
      if(o.indexOf(&quot;.&quot;) === -1) o = o[0] + &quot;.&quot; + o.substr(1) + &quot;E+&quot; + (fakee - o.length+ee);
      else o += &quot;E+&quot; + (fakee - ee);
      o = o.replace(/\+-/,&quot;-&quot;);
    }
    o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/,function($$,$1,$2,$3) { return $1 + $2 + $3.substr(0,(period+ee)%period) + &quot;.&quot; + $3.substr(ee) + &quot;E&quot;; });
  } else o = val.toExponential(idx);
  if(fmt.match(/E\+00$/) &amp;&amp; o.match(/e[+-]\d$/)) o = o.substr(0,o.length-1) + &quot;0&quot; + o[o.length-1];
  if(fmt.match(/E\-/) &amp;&amp; o.match(/e\+/)) o = o.replace(/e\+/,&quot;e&quot;);
  return o.replace(&quot;e&quot;,&quot;E&quot;);
}
function write_num_int(type, fmt, val) {
  if(type.charCodeAt(0) === 40 &amp;&amp; !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */,&quot;&quot;).replace(/ \)/,&quot;&quot;).replace(/\)/,&quot;&quot;);
    if(val &gt;= 0) return write_num_int(&#39;n&#39;, ffmt, val);
    return &#39;(&#39; + write_num_int(&#39;n&#39;, ffmt, -val) + &#39;)&#39;;
  }
  if(fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
  if(fmt.indexOf(&#39;%&#39;) !== -1) return write_num_pct2(type, fmt, val);
  if(fmt.indexOf(&#39;E&#39;) !== -1) return write_num_exp2(fmt, val);
  if(fmt.charCodeAt(0) === 36) return &quot;$&quot;+write_num_int(type,fmt.substr(fmt[1]==&#39; &#39;?2:1),val);
  var o;
  var r, ri, ff, aval = Math.abs(val), sign = val &lt; 0 ? &quot;-&quot; : &quot;&quot;;
  if(fmt.match(/^00+$/)) return sign + pad0(aval,fmt.length);
  if(fmt.match(/^[#?]+$/)) {
    o = (&quot;&quot;+val); if(val === 0) o = &quot;&quot;;
    return o.length &gt; fmt.length ? o : hashq(fmt.substr(0,fmt.length-o.length)) + o;
  }
  if((r = fmt.match(frac1)) !== null) return write_num_f2(r, aval, sign);
  if(fmt.match(/^#+0+$/) !== null) return sign + pad0(aval,fmt.length - fmt.indexOf(&quot;0&quot;));
  if((r = fmt.match(dec1)) !== null) {
    o = (&quot;&quot;+val).replace(/^([^\.]+)$/,&quot;$1.&quot;+r[1]).replace(/\.$/,&quot;.&quot;+r[1]).replace(/\.(\d*)$/,function($$, $1) { return &quot;.&quot; + $1 + fill(&quot;0&quot;, r[1].length-$1.length); });
    return fmt.indexOf(&quot;0.&quot;) !== -1 ? o : o.replace(/^0\./,&quot;.&quot;);
  }
  fmt = fmt.replace(/^#+([0.])/, &quot;$1&quot;);
  if((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
    return sign + (&quot;&quot;+aval).replace(/\.(\d*[1-9])0*$/,&quot;.$1&quot;).replace(/^(-?\d*)$/,&quot;$1.&quot;).replace(/^0\./,r[1].length?&quot;0.&quot;:&quot;.&quot;);
  }
  if((r = fmt.match(/^#,##0(\.?)$/)) !== null) return sign + commaify((&quot;&quot;+aval));
  if((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
    return val &lt; 0 ? &quot;-&quot; + write_num_int(type, fmt, -val) : commaify((&quot;&quot;+val)) + &quot;.&quot; + fill(&#39;0&#39;,r[1].length);
  }
  if((r = fmt.match(/^#,#*,#0/)) !== null) return write_num_int(type,fmt.replace(/^#,#*,/,&quot;&quot;),val);
  if((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
    o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g,&quot;&quot;), val));
    ri = 0;
    return _strrev(_strrev(fmt.replace(/\\/g,&quot;&quot;)).replace(/[0#]/g,function(x){return ri&lt;o.length?o[ri++]:x===&#39;0&#39;?&#39;0&#39;:&quot;&quot;;}));
  }
  if(fmt.match(phone) !== null) {
    o = write_num_int(type, &quot;##########&quot;, val);
    return &quot;(&quot; + o.substr(0,3) + &quot;) &quot; + o.substr(3, 3) + &quot;-&quot; + o.substr(6);
  }
  var oa = &quot;&quot;;
  if((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
    ri = Math.min(r[4].length,7);
    ff = frac(aval, Math.pow(10,ri)-1, false);
    o = &quot;&quot; + sign;
    oa = write_num(&quot;n&quot;, r[1], ff[1]);
    if(oa[oa.length-1] == &quot; &quot;) oa = oa.substr(0,oa.length-1) + &quot;0&quot;;
    o += oa + r[2] + &quot;/&quot; + r[3];
    oa = rpad_(ff[2],ri);
    if(oa.length &lt; r[4].length) oa = hashq(r[4].substr(r[4].length-oa.length)) + oa;
    o += oa;
    return o;
  }
  if((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
    ri = Math.min(Math.max(r[1].length, r[4].length),7);
    ff = frac(aval, Math.pow(10,ri)-1, true);
    return sign + (ff[0]||(ff[1] ? &quot;&quot; : &quot;0&quot;)) + &quot; &quot; + (ff[1] ? pad_(ff[1],ri) + r[2] + &quot;/&quot; + r[3] + rpad_(ff[2],ri): fill(&quot; &quot;, 2*ri+1 + r[2].length + r[3].length));
  }
  if((r = fmt.match(/^[#0?]+$/)) !== null) {
    o = &quot;&quot; + val;
    if(fmt.length &lt;= o.length) return o;
    return hashq(fmt.substr(0,fmt.length-o.length)) + o;
  }
  if((r = fmt.match(/^([#0]+)\.([#0]+)$/)) !== null) {
    o = &quot;&quot; + val.toFixed(Math.min(r[2].length,10)).replace(/([^0])0+$/,&quot;$1&quot;);
    ri = o.indexOf(&quot;.&quot;);
    var lres = fmt.indexOf(&quot;.&quot;) - ri, rres = fmt.length - o.length - lres;
    return hashq(fmt.substr(0,lres) + o + fmt.substr(fmt.length-rres));
  }
  if((r = fmt.match(/^00,000\.([#0]*0)$/)) !== null) {
    return val &lt; 0 ? &quot;-&quot; + write_num_int(type, fmt, -val) : commaify(&quot;&quot;+val).replace(/^\d,\d{3}$/,&quot;0$&amp;&quot;).replace(/^\d*$/,function($$) { return &quot;00,&quot; + ($$.length &lt; 3 ? pad0(0,3-$$.length) : &quot;&quot;) + $$; }) + &quot;.&quot; + pad0(0,r[1].length);
  }
  switch(fmt) {
    case &quot;#,###&quot;: var x = commaify(&quot;&quot;+aval); return x !== &quot;0&quot; ? sign + x : &quot;&quot;;
    default:
  }
  throw new Error(&quot;unsupported format |&quot; + fmt + &quot;|&quot;);
}</code></pre>
<p>The final function simply dispatches:</p>
<pre><code>return function write_num(type, fmt, val) {
  return (val|0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
};})();</code></pre>
<h2 id="evaluating-format-strings">Evaluating Format Strings</h2>
<div class="sourceCode" id="cb61"><pre class="sourceCode js&gt;tmp/82_eval.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">var</span> abstime <span class="op">=</span> <span class="ss">/</span><span class="sc">\[[HhMmSs]*\]</span><span class="ss">/</span><span class="op">;</span></a>
<a class="sourceLine" id="cb61-2" title="2"><span class="kw">function</span> <span class="at">eval_fmt</span>(fmt<span class="op">,</span> v<span class="op">,</span> opts<span class="op">,</span> flen) <span class="op">{</span></a>
<a class="sourceLine" id="cb61-3" title="3">  <span class="kw">var</span> out <span class="op">=</span> []<span class="op">,</span> o <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">,</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> c <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">,</span> lst<span class="op">=</span><span class="st">&#39;t&#39;</span><span class="op">,</span> q<span class="op">,</span> dt<span class="op">,</span> j<span class="op">,</span> cc<span class="op">;</span></a>
<a class="sourceLine" id="cb61-4" title="4">  <span class="kw">var</span> hr<span class="op">=</span><span class="st">&#39;H&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb61-5" title="5">  <span class="co">/* Tokenize */</span></a>
<a class="sourceLine" id="cb61-6" title="6">  <span class="cf">while</span>(i <span class="op">&lt;</span> <span class="va">fmt</span>.<span class="at">length</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb61-7" title="7">    <span class="cf">switch</span>((c <span class="op">=</span> fmt[i])) <span class="op">{</span></a></code></pre></div>
<p>LO Formats sometimes leak “GENERAL” or “General” to stand for general format:</p>
<pre><code>      case &#39;G&#39;: /* General */
        if(!isgeneral(fmt, i)) throw new Error(&#39;unrecognized character &#39; + c + &#39; in &#39; +fmt);
        out[out.length] = {t:&#39;G&#39;, v:&#39;General&#39;}; i+=7; break;</code></pre>
<p>Text between double-quotes are treated literally, and individual characters are literal if they are preceded by a slash.</p>
<p>The additional <code>i &lt; fmt.length</code> guard was added due to potentially unterminated strings generated by LO:</p>
<pre><code>      case &#39;&quot;&#39;: /* Literal text */
        for(o=&quot;&quot;;(cc=fmt.charCodeAt(++i)) !== 34 &amp;&amp; i &lt; fmt.length;) o += String.fromCharCode(cc);
        out[out.length] = {t:&#39;t&#39;, v:o}; ++i; break;
      case &#39;\\&#39;: var w = fmt[++i], t = (w === &quot;(&quot; || w === &quot;)&quot;) ? w : &#39;t&#39;;
        out[out.length] = {t:t, v:w}; ++i; break;</code></pre>
<p>The underscore character represents a literal space. Apparently, it also marks that the next character is junk. Hence the read pointer is moved by 2:</p>
<pre><code>      case &#39;_&#39;: out[out.length] = {t:&#39;t&#39;, v:&quot; &quot;}; i+=2; break;</code></pre>
<p>The ‘@’ symbol refers to the original text. The ECMA spec is not complete, but Excel does not allow for ‘@’ and non-literal text to appear in the same format. It seems as if they only support one mode. (clearly this is a TODO for excel mode but I’m not convinced that’s the right approach)</p>
<pre><code>      case &#39;@&#39;: /* Text Placeholder */
        out[out.length] = {t:&#39;T&#39;, v:v}; ++i; break;</code></pre>
<p><code>B1</code> and <code>B2</code> specify which calendar to use, while <code>b</code> is the buddhist year. It acts just like <code>y</code> except the year is shifted:</p>
<pre><code>      case &#39;B&#39;: case &#39;b&#39;:
        if(fmt[i+1] === &quot;1&quot; || fmt[i+1] === &quot;2&quot;) {
          if(dt==null) { dt=parse_date_code(v, opts, fmt[i+1] === &quot;2&quot;); if(dt==null) return &quot;&quot;; }
          out[out.length] = {t:&#39;X&#39;, v:fmt.substr(i,2)}; lst = c; i+=2; break;
        }
        /* falls through */</code></pre>
<p>The date codes <code>m,d,y,h,s</code> are standard. There are some special formats like <code>e / g</code> (era year) that have different behaviors in Japanese/Chinese locales.</p>
<pre><code>      case &#39;M&#39;: case &#39;D&#39;: case &#39;Y&#39;: case &#39;H&#39;: case &#39;S&#39;: case &#39;E&#39;:
        c = c.toLowerCase();
        /* falls through */
      case &#39;m&#39;: case &#39;d&#39;: case &#39;y&#39;: case &#39;h&#39;: case &#39;s&#39;: case &#39;e&#39;: case &#39;g&#39;:</code></pre>
<p>Negative dates are immediately thrown out:</p>
<pre><code>        if(v &lt; 0) return &quot;&quot;;</code></pre>
<p>Merge strings like “mmmmm” or “hh” into one block:</p>
<pre><code>        if(dt==null) { dt=parse_date_code(v, opts); if(dt==null) return &quot;&quot;; }
        o = c; while(++i&lt;fmt.length &amp;&amp; fmt[i].toLowerCase() === c) o+=c;</code></pre>
<p>Only the forward corrections are made here. The reverse corrections are made later:</p>
<pre><code>        if(c === &#39;m&#39; &amp;&amp; lst.toLowerCase() === &#39;h&#39;) c = &#39;M&#39;; /* m = minute */
        if(c === &#39;h&#39;) c = hr;
        out[out.length] = {t:c, v:o}; lst = c; break;</code></pre>
<p>The (poorly documented) rule regarding <code>A/P</code> and <code>AM/PM</code> is that if they show up in the format then <em>all</em> instances of <code>h</code> are considered 12-hour and not 24-hour format (even in cases like <code>hh AM/PM hh hh hh</code>).</p>
<p>However, the undocumented <code>H</code> and <code>HH</code> do appear to reset the <code>AM/PM</code> indicator. It is not implemented at the moment because I am not 100% sure of the rules with the HH/hh jazz. TODO: investigate this further.</p>
<pre><code>      case &#39;A&#39;:
        q={t:c, v:&quot;A&quot;};
        if(dt==null) dt=parse_date_code(v, opts);
        if(fmt.substr(i, 3) === &quot;A/P&quot;) { if(dt!=null) q.v = dt.H &gt;= 12 ? &quot;P&quot; : &quot;A&quot;; q.t = &#39;T&#39;; hr=&#39;h&#39;;i+=3;}
        else if(fmt.substr(i,5) === &quot;AM/PM&quot;) { if(dt!=null) q.v = dt.H &gt;= 12 ? &quot;PM&quot; : &quot;AM&quot;; q.t = &#39;T&#39;; i+=5; hr=&#39;h&#39;; }
        else { q.t = &quot;t&quot;; ++i; }
        if(dt==null &amp;&amp; q.t === &#39;T&#39;) return &quot;&quot;;
        out[out.length] = q; lst = c; break;</code></pre>
<p>Conditional and color blocks should be handled at one point (TODO). The pseudo-type <code>Z</code> is used to capture absolute time blocks:</p>
<pre><code>      case &#39;[&#39;:
        o = c;
        while(fmt[i++] !== &#39;]&#39; &amp;&amp; i &lt; fmt.length) o += fmt[i];
        if(o.substr(-1) !== &#39;]&#39;) throw &#39;unterminated &quot;[&quot; block: |&#39; + o + &#39;|&#39;;
        if(o.match(abstime)) {
          if(dt==null) { dt=parse_date_code(v, opts); if(dt==null) return &quot;&quot;; }
          out[out.length] = {t:&#39;Z&#39;, v:o.toLowerCase()};
        } else { o=&quot;&quot;; }
        break;</code></pre>
<p>Number blocks (following the general pattern <code>[0#?][0#?.,E+-%]*</code>) are grouped together. Literal hyphens are swallowed as well. Since <code>.000</code> is a valid term (for tenths/hundredths/thousandths of a second), it must be handled separately:</p>
<pre><code>      /* Numbers */
      case &#39;.&#39;:
        if(dt != null) {
          o = c; while((c=fmt[++i]) === &quot;0&quot;) o += c;
          out[out.length] = {t:&#39;s&#39;, v:o}; break;
        }
        /* falls through */
      case &#39;0&#39;: case &#39;#&#39;:
        o = c; while(&quot;0#?.,E+-%&quot;.indexOf(c=fmt[++i]) &gt; -1 || c==&#39;\\&#39; &amp;&amp; fmt[i+1] == &quot;-&quot; &amp;&amp; &quot;0#&quot;.indexOf(fmt[i+2])&gt;-1) o += c;
        out[out.length] = {t:&#39;n&#39;, v:o}; break;
</code></pre>
<p>The fraction question mark characters present their own challenges. For example, the number 123.456 under format <code>|??| /  |???| |???| foo</code> is <code>|15432| /  |125| |   | foo</code>:</p>
<pre><code>      case &#39;?&#39;:
        o = c; while(fmt[++i] === c) o+=c;
        q={t:c, v:o}; out[out.length] = q; lst = c; break;</code></pre>
<p>Due to how the CSV generation works, asterisk characters are discarded. TODO: communicate this somehow, possibly with an option</p>
<pre><code>      case &#39;*&#39;: ++i; if(fmt[i] == &#39; &#39; || fmt[i] == &#39;*&#39;) ++i; break; // **</code></pre>
<p>The open and close parens <code>()</code> also has special meaning (for negative numbers):</p>
<pre><code>      case &#39;(&#39;: case &#39;)&#39;: out[out.length] = {t:(flen===1?&#39;t&#39;:c), v:c}; ++i; break;</code></pre>
<p>The nonzero digits show up in fraction denominators:</p>
<pre><code>      case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;: case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;: case &#39;9&#39;:
        o = c; while(&quot;0123456789&quot;.indexOf(fmt[++i]) &gt; -1) o+=fmt[i];
        out[out.length] = {t:&#39;D&#39;, v:o}; break;</code></pre>
<p>The default magic characters are listed in subsubsections 18.8.30-31 of ECMA376:</p>
<pre><code>      case &#39; &#39;: out[out.length] = {t:c, v:c}; ++i; break;
      default:
        if(&quot;,$-+/():!^&amp;&#39;~{}&lt;&gt;=€acfijklopqrtuvwxz&quot;.indexOf(c) === -1) throw new Error(&#39;unrecognized character &#39; + c + &#39; in &#39; + fmt);
        out[out.length] = {t:&#39;t&#39;, v:c}; ++i; break;
    }
  }</code></pre>
<p>In order to identify cases like <code>MMSS</code>, where the fact that this is a minute appears after the minute itself, scan backwards. At the same time, we can identify the smallest time unit (0 = no time, 1 = hour, 2 = minute, 3 = second) and the required number of digits for the sub-seconds:</p>
<pre><code>  var bt = 0, ss0 = 0, ssm;
  for(i=out.length-1, lst=&#39;t&#39;; i &gt;= 0; --i) {
    switch(out[i].t) {
      case &#39;h&#39;: case &#39;H&#39;: out[i].t = hr; lst=&#39;h&#39;; if(bt &lt; 1) bt = 1; break;
      case &#39;s&#39;:
        if((ssm=out[i].v.match(/\.0+$/))) ss0=Math.max(ss0,ssm[0].length-1);
        if(bt &lt; 3) bt = 3;
      /* falls through */
      case &#39;d&#39;: case &#39;y&#39;: case &#39;M&#39;: case &#39;e&#39;: lst=out[i].t; break;
      case &#39;m&#39;: if(lst === &#39;s&#39;) { out[i].t = &#39;M&#39;; if(bt &lt; 2) bt = 2; } break;
      case &#39;X&#39;: if(out[i].v === &quot;B2&quot;);
        break;
      case &#39;Z&#39;:
        if(bt &lt; 1 &amp;&amp; out[i].v.match(/[Hh]/)) bt = 1;
        if(bt &lt; 2 &amp;&amp; out[i].v.match(/[Mm]/)) bt = 2;
        if(bt &lt; 3 &amp;&amp; out[i].v.match(/[Ss]/)) bt = 3;
    }
  }</code></pre>
<p>Having determined the smallest time unit, round appropriately:</p>
<pre><code>  switch(bt) {
    case 0: break;
    case 1:
      if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }
      if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }
      if(dt.M &gt;=  60) { dt.M = 0; ++dt.H; }
      break;
    case 2:
      if(dt.u &gt;= 0.5) { dt.u = 0; ++dt.S; }
      if(dt.S &gt;=  60) { dt.S = 0; ++dt.M; }
      break;
  }</code></pre>
<p>Since number groups in a string should be treated as part of the same whole, group them together to construct the real number string:</p>
<pre><code>  /* replace fields */
  var nstr = &quot;&quot;, jj;
  for(i=0; i &lt; out.length; ++i) {
    switch(out[i].t) {
      case &#39;t&#39;: case &#39;T&#39;: case &#39; &#39;: case &#39;D&#39;: break;
      case &#39;X&#39;: out[i] = undefined; break;
      case &#39;d&#39;: case &#39;m&#39;: case &#39;y&#39;: case &#39;h&#39;: case &#39;H&#39;: case &#39;M&#39;: case &#39;s&#39;: case &#39;e&#39;: case &#39;b&#39;: case &#39;Z&#39;:
        out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
        out[i].t = &#39;t&#39;; break;
      case &#39;n&#39;: case &#39;(&#39;: case &#39;?&#39;:
        jj = i+1;
        while(out[jj] != null &amp;&amp; (
          (c=out[jj].t) === &quot;?&quot; || c === &quot;D&quot; ||
          (c === &quot; &quot; || c === &quot;t&quot;) &amp;&amp; out[jj+1] != null &amp;&amp; (out[jj+1].t === &#39;?&#39; || out[jj+1].t === &quot;t&quot; &amp;&amp; out[jj+1].v === &#39;/&#39;) ||
          out[i].t === &#39;(&#39; &amp;&amp; (c === &#39; &#39; || c === &#39;n&#39; || c === &#39;)&#39;) ||
          c === &#39;t&#39; &amp;&amp; (out[jj].v === &#39;/&#39; || &#39;$€&#39;.indexOf(out[jj].v) &gt; -1 || out[jj].v === &#39; &#39; &amp;&amp; out[jj+1] != null &amp;&amp; out[jj+1].t == &#39;?&#39;)
        )) {
          out[i].v += out[jj].v;
          out[jj] = undefined; ++jj;
        }
        nstr += out[i].v;
        i = jj-1; break;
      case &#39;G&#39;: out[i].t = &#39;t&#39;; out[i].v = general_fmt(v,opts); break;
    }
  }</code></pre>
<p>Next, process the complete number string:</p>
<pre><code>  var vv = &quot;&quot;, myv, ostr;
  if(nstr.length &gt; 0) {
    myv = (v&lt;0&amp;&amp;nstr.charCodeAt(0) === 45 ? -v : v); /* &#39;-&#39; */
    ostr = write_num(nstr.charCodeAt(0) === 40 ? &#39;(&#39; : &#39;n&#39;, nstr, myv); /* &#39;(&#39; */
    jj=ostr.length-1;</code></pre>
<p>Find the first decimal point:</p>
<pre><code>    var decpt = out.length;
    for(i=0; i &lt; out.length; ++i) if(out[i] != null &amp;&amp; out[i].v.indexOf(&quot;.&quot;) &gt; -1) { decpt = i; break; }
    var lasti=out.length;</code></pre>
<p>If there is no decimal point or exponential, the algorithm is straightforward:</p>
<pre><code>    if(decpt === out.length &amp;&amp; ostr.indexOf(&quot;E&quot;) === -1) {
      for(i=out.length-1; i&gt;= 0;--i) {
        if(out[i] == null || &#39;n?(&#39;.indexOf(out[i].t) === -1) continue;
        if(jj&gt;=out[i].v.length-1) { jj -= out[i].v.length; out[i].v = ostr.substr(jj+1, out[i].v.length); }
        else if(jj &lt; 0) out[i].v = &quot;&quot;;
        else { out[i].v = ostr.substr(0, jj+1); jj = -1; }
        out[i].t = &#39;t&#39;;
        lasti = i;
      }
      if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
    }</code></pre>
<p>Otherwise we have to do something a bit trickier:</p>
<pre><code>    else if(decpt !== out.length &amp;&amp; ostr.indexOf(&quot;E&quot;) === -1) {
      jj = ostr.indexOf(&quot;.&quot;)-1;
      for(i=decpt; i&gt;= 0; --i) {
        if(out[i] == null || &#39;n?(&#39;.indexOf(out[i].t) === -1) continue;
        j=out[i].v.indexOf(&quot;.&quot;)&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(&quot;.&quot;)-1:out[i].v.length-1;
        vv = out[i].v.substr(j+1);
        for(; j&gt;=0; --j) {
          if(jj&gt;=0 &amp;&amp; (out[i].v[j] === &quot;0&quot; || out[i].v[j] === &quot;#&quot;)) vv = ostr[jj--] + vv;
        }
        out[i].v = vv;
        out[i].t = &#39;t&#39;;
        lasti = i;
      }
      if(jj&gt;=0 &amp;&amp; lasti&lt;out.length) out[lasti].v = ostr.substr(0,jj+1) + out[lasti].v;
      jj = ostr.indexOf(&quot;.&quot;)+1;
      for(i=decpt; i&lt;out.length; ++i) {
        if(out[i] == null || &#39;n?(&#39;.indexOf(out[i].t) === -1 &amp;&amp; i !== decpt ) continue;
        j=out[i].v.indexOf(&quot;.&quot;)&gt;-1&amp;&amp;i===decpt?out[i].v.indexOf(&quot;.&quot;)+1:0;
        vv = out[i].v.substr(0,j);
        for(; j&lt;out[i].v.length; ++j) {
          if(jj&lt;ostr.length) vv += ostr[jj++];
        }
        out[i].v = vv;
        out[i].t = &#39;t&#39;;
        lasti = i;
      }
    }
  }</code></pre>
<p>The magic in the next line is to ensure that the negative number is passed as positive when there is an explicit hyphen before it (e.g. <code>#,##0.0;-#,##0.0</code>):</p>
<pre><code>  for(i=0; i&lt;out.length; ++i) if(out[i] != null &amp;&amp; &#39;n(?&#39;.indexOf(out[i].t)&gt;-1) {
    myv = (flen &gt;1 &amp;&amp; v &lt; 0 &amp;&amp; i&gt;0 &amp;&amp; out[i-1].v === &quot;-&quot; ? -v:v);
    out[i].v = write_num(out[i].t, out[i].v, myv);
    out[i].t = &#39;t&#39;;
  }</code></pre>
<p>Now we just need to combine the elements</p>
<pre><code>  var retval = &quot;&quot;;
  for(i=0; i !== out.length; ++i) if(out[i] != null) retval += out[i].v;
  return retval;
}
SSF._eval = eval_fmt;</code></pre>
<p>There is some overloading of the <code>m</code> character. According to the spec:</p>
<blockquote>
<p>If “m” or “mm” code is used immediately after the “h” or “hh” code (for hours) or immediately before the “ss” code (for seconds), the application shall display minutes instead of the month.</p>
</blockquote>
<div class="sourceCode" id="cb88"><pre class="sourceCode js&gt;tmp/50_date.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb88-1" title="1"><span class="co">/*jshint -W086 */</span></a>
<a class="sourceLine" id="cb88-2" title="2"><span class="kw">function</span> <span class="at">write_date</span>(type<span class="op">,</span> fmt<span class="op">,</span> val<span class="op">,</span> ss0) <span class="op">{</span></a>
<a class="sourceLine" id="cb88-3" title="3">  <span class="kw">var</span> o<span class="op">=</span><span class="st">&quot;&quot;</span><span class="op">,</span> ss<span class="op">=</span><span class="dv">0</span><span class="op">,</span> tt<span class="op">=</span><span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="va">val</span>.<span class="at">y</span><span class="op">,</span> out<span class="op">,</span> outl <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb88-4" title="4">  <span class="cf">switch</span>(type) <span class="op">{</span></a></code></pre></div>
<p><code>b</code> years are shifted by 543 (<code>y</code> 1900 == <code>b</code> 2443):</p>
<pre><code>    case 98: /* &#39;b&#39; buddhist year */
      y = val.y + 543;
      /* falls through */</code></pre>
<p><code>yyyyyyyyyyyyyyyyyyyy</code> is a 4 digit year</p>
<pre><code>    case 121: /* &#39;y&#39; year */
    switch(fmt.length) {
      case 1: case 2: out = y % 100; outl = 2; break;
      default: out = y % 10000; outl = 4; break;
    } break;</code></pre>
<p><code>mmmmmmmmmmmmmmmmmmmm</code> is treated as the full month name:</p>
<pre><code>    case 109: /* &#39;m&#39; month */
    switch(fmt.length) {
      case 1: case 2: out = val.m; outl = fmt.length; break;
      case 3: return months[val.m-1][1];
      case 5: return months[val.m-1][0];
      default: return months[val.m-1][2];
    } break;</code></pre>
<p><code>dddddddddddddddddddd</code> is treated as the full day name:</p>
<pre><code>    case 100: /* &#39;d&#39; day */
    switch(fmt.length) {
      case 1: case 2: out = val.d; outl = fmt.length; break;
      case 3: return days[val.q][0];
      default: return days[val.q][1];
    } break;</code></pre>
<p>Abnormal hours and minutes are rejected:</p>
<pre><code>    case 104: /* &#39;h&#39; 12-hour */
    switch(fmt.length) {
      case 1: case 2: out = 1+(val.H+11)%12; outl = fmt.length; break;
      default: throw &#39;bad hour format: &#39; + fmt;
    } break;
    case 72: /* &#39;H&#39; 24-hour */
    switch(fmt.length) {
      case 1: case 2: out = val.H; outl = fmt.length; break;
      default: throw &#39;bad hour format: &#39; + fmt;
    } break;
    case 77: /* &#39;M&#39; minutes */
    switch(fmt.length) {
      case 1: case 2: out = val.M; outl = fmt.length; break;
      default: throw &#39;bad minute format: &#39; + fmt;
    } break;</code></pre>
<p>Unfortunately, the actual subsecond string is based on the presence of other terms. That is passed via the <code>ss0</code> parameter:</p>
<pre><code>    case 115: /* &#39;s&#39; seconds */
    if(val.u === 0) switch(fmt) {
      case &#39;s&#39;: case &#39;ss&#39;: return pad0(val.S, fmt.length);
      case &#39;.0&#39;: case &#39;.00&#39;: case &#39;.000&#39;:
    }
    switch(fmt) {
      case &#39;s&#39;: case &#39;ss&#39;: case &#39;.0&#39;: case &#39;.00&#39;: case &#39;.000&#39;:
        if(ss0 &gt;= 2) tt = ss0 === 3 ? 1000 : 100;
        else tt = ss0 === 1 ? 10 : 1;
        ss = Math.round((tt)*(val.S + val.u));
        if(ss &gt;= 60*tt) ss = 0;
        if(fmt === &#39;s&#39;) return ss === 0 ? &quot;0&quot; : &quot;&quot;+ss/tt;
        o = pad0(ss,2 + ss0);
        if(fmt === &#39;ss&#39;) return o.substr(0,2);
        return &quot;.&quot; + o.substr(2,fmt.length-1);
      default: throw &#39;bad second format: &#39; + fmt;
    }</code></pre>
<p>The <code>Z</code> type refers to absolute time measures:</p>
<pre><code>    case 90: /* &#39;Z&#39; absolute time */
    switch(fmt) {
      case &#39;[h]&#39;: case &#39;[hh]&#39;: out = val.D*24+val.H; break;
      case &#39;[m]&#39;: case &#39;[mm]&#39;: out = (val.D*24+val.H)*60+val.M; break;
      case &#39;[s]&#39;: case &#39;[ss]&#39;: out = ((val.D*24+val.H)*60+val.M)*60+Math.round(val.S+val.u); break;
      default: throw &#39;bad abstime format: &#39; + fmt;
    } outl = fmt.length === 3 ? 1 : 2; break;</code></pre>
<p>The <code>e</code> format behavior in excel diverges from the spec. It claims that <code>ee</code> should be a two-digit year, but <code>ee</code> in excel is actually the four-digit year:</p>
<pre><code>    case 101: /* &#39;e&#39; era */
      out = y; outl = 1;</code></pre>
<p>There is no input to the function that ends up triggering the default behavior: it is not exported and is only called when the type is in <code>ymdhHMsZe</code></p>
<pre><code>  }
  if(outl &gt; 0) return pad0(out, outl); else return &quot;&quot;;
}
/*jshint +W086 */</code></pre>
<p>Based on the value, <code>choose_fmt</code> picks the right format string. If formats have explicit negative specifications, those values should be passed as positive:</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode js&gt;tmp/90_main.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb98-1" title="1"><span class="kw">function</span> <span class="at">choose_fmt</span>(f<span class="op">,</span> v) <span class="op">{</span></a>
<a class="sourceLine" id="cb98-2" title="2">  <span class="kw">var</span> fmt <span class="op">=</span> <span class="at">split_fmt</span>(f)<span class="op">;</span></a>
<a class="sourceLine" id="cb98-3" title="3">  <span class="kw">var</span> l <span class="op">=</span> <span class="va">fmt</span>.<span class="at">length</span><span class="op">,</span> lat <span class="op">=</span> fmt[l<span class="dv">-1</span>].<span class="at">indexOf</span>(<span class="st">&quot;@&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb98-4" title="4">  <span class="cf">if</span>(l<span class="op">&lt;</span><span class="dv">4</span> <span class="op">&amp;&amp;</span> lat<span class="op">&gt;-</span><span class="dv">1</span>) <span class="op">--</span>l<span class="op">;</span></a>
<a class="sourceLine" id="cb98-5" title="5">  <span class="cf">if</span>(<span class="va">fmt</span>.<span class="at">length</span> <span class="op">&gt;</span> <span class="dv">4</span>) <span class="cf">throw</span> <span class="st">&quot;cannot find right format for |&quot;</span> <span class="op">+</span> fmt <span class="op">+</span> <span class="st">&quot;|&quot;</span><span class="op">;</span></a></code></pre></div>
<p>Short-circuit the string case by using the last format if it has “@”:</p>
<pre><code>  if(typeof v !== &quot;number&quot;) return [4, fmt.length === 4 || lat&gt;-1?fmt[fmt.length-1]:&quot;@&quot;];
  switch(fmt.length) {</code></pre>
<p>In the case of one format, if it contains an “@” then it is a text format. There is a big TODO here regarding how to best handle this case.</p>
<pre><code>    case 1: fmt = lat&gt;-1 ? [&quot;General&quot;, &quot;General&quot;, &quot;General&quot;, fmt[0]] : [fmt[0], fmt[0], fmt[0], &quot;@&quot;]; break;</code></pre>
<p>In the case of 2 or 3 formats, if an <code>@</code> appears in the last field of the format it is treated as the text format</p>
<pre><code>    case 2: fmt = lat&gt;-1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], &quot;@&quot;]; break;
    case 3: fmt = lat&gt;-1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], &quot;@&quot;]; break;
    case 4: break;
  }</code></pre>
<p>Here we have to scan for conditions. Note that the grammar precludes decimals but in practice they are fair game:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode js&gt;tmp/88_cond.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb102-1" title="1"><span class="kw">var</span> cfregex <span class="op">=</span> <span class="ss">/</span><span class="sc">\[[=&lt;&gt;]</span><span class="ss">/</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-2" title="2"><span class="kw">var</span> cfregex2 <span class="op">=</span> <span class="ss">/</span><span class="sc">\[([=&lt;&gt;]*)(</span><span class="ss">-</span><span class="sc">?\d+\.?\d*)\]</span><span class="ss">/</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-3" title="3"><span class="kw">function</span> <span class="at">chkcond</span>(v<span class="op">,</span> rr) <span class="op">{</span></a>
<a class="sourceLine" id="cb102-4" title="4">  <span class="cf">if</span>(rr <span class="op">==</span> <span class="kw">null</span>) <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-5" title="5">  <span class="kw">var</span> thresh <span class="op">=</span> <span class="at">parseFloat</span>(rr[<span class="dv">2</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb102-6" title="6">  <span class="cf">switch</span>(rr[<span class="dv">1</span>]) <span class="op">{</span></a>
<a class="sourceLine" id="cb102-7" title="7">    <span class="cf">case</span> <span class="st">&quot;=&quot;</span><span class="op">:</span>  <span class="cf">if</span>(v <span class="op">==</span> thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-8" title="8">    <span class="cf">case</span> <span class="st">&quot;&gt;&quot;</span><span class="op">:</span>  <span class="cf">if</span>(v <span class="op">&gt;</span>  thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-9" title="9">    <span class="cf">case</span> <span class="st">&quot;&lt;&quot;</span><span class="op">:</span>  <span class="cf">if</span>(v <span class="op">&lt;</span>  thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-10" title="10">    <span class="cf">case</span> <span class="st">&quot;&lt;&gt;&quot;</span><span class="op">:</span> <span class="cf">if</span>(v <span class="op">!=</span> thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-11" title="11">    <span class="cf">case</span> <span class="st">&quot;&gt;=&quot;</span><span class="op">:</span> <span class="cf">if</span>(v <span class="op">&gt;=</span> thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-12" title="12">    <span class="cf">case</span> <span class="st">&quot;&lt;=&quot;</span><span class="op">:</span> <span class="cf">if</span>(v <span class="op">&lt;=</span> thresh) <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb102-14" title="14">  <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></a>
<a class="sourceLine" id="cb102-15" title="15"><span class="op">}</span></a></code></pre></div>
<p>The main function checks for conditional operators and acts accordingly:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode js&gt;tmp/90_main.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb103-1" title="1">  <span class="kw">var</span> ff <span class="op">=</span> v <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> fmt[<span class="dv">0</span>] : v <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">?</span> fmt[<span class="dv">1</span>] : fmt[<span class="dv">2</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb103-2" title="2">  <span class="cf">if</span>(fmt[<span class="dv">0</span>].<span class="at">indexOf</span>(<span class="st">&quot;[&quot;</span>) <span class="op">===</span> <span class="dv">-1</span> <span class="op">&amp;&amp;</span> fmt[<span class="dv">1</span>].<span class="at">indexOf</span>(<span class="st">&quot;[&quot;</span>) <span class="op">===</span> <span class="dv">-1</span>) <span class="cf">return</span> [l<span class="op">,</span> ff]<span class="op">;</span></a>
<a class="sourceLine" id="cb103-3" title="3">  <span class="cf">if</span>(fmt[<span class="dv">0</span>].<span class="at">match</span>(cfregex) <span class="op">!=</span> <span class="kw">null</span> <span class="op">||</span> fmt[<span class="dv">1</span>].<span class="at">match</span>(cfregex) <span class="op">!=</span> <span class="kw">null</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb103-4" title="4">    <span class="kw">var</span> m1 <span class="op">=</span> fmt[<span class="dv">0</span>].<span class="at">match</span>(cfregex2)<span class="op">;</span></a>
<a class="sourceLine" id="cb103-5" title="5">    <span class="kw">var</span> m2 <span class="op">=</span> fmt[<span class="dv">1</span>].<span class="at">match</span>(cfregex2)<span class="op">;</span></a>
<a class="sourceLine" id="cb103-6" title="6">    <span class="cf">return</span> <span class="at">chkcond</span>(v<span class="op">,</span> m1) <span class="op">?</span> [l<span class="op">,</span> fmt[<span class="dv">0</span>]] : <span class="at">chkcond</span>(v<span class="op">,</span> m2) <span class="op">?</span> [l<span class="op">,</span> fmt[<span class="dv">1</span>]] : [l<span class="op">,</span> fmt[m1 <span class="op">!=</span> <span class="kw">null</span> <span class="op">&amp;&amp;</span> m2 <span class="op">!=</span> <span class="kw">null</span> <span class="op">?</span> <span class="dv">2</span> : <span class="dv">1</span>]]<span class="op">;</span></a>
<a class="sourceLine" id="cb103-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb103-8" title="8">  <span class="cf">return</span> [l<span class="op">,</span> ff]<span class="op">;</span></a>
<a class="sourceLine" id="cb103-9" title="9">}</a></code></pre></div>
<p>Finally, the format wrapper brings everything together:</p>
<pre><code>function format(fmt,v,o) {
  fixopts(o != null ? o : (o=[]));</code></pre>
<p>The string format is saved to a different variable:</p>
<pre><code>  var sfmt = &quot;&quot;;
  switch(typeof fmt) {
    case &quot;string&quot;: sfmt = fmt; break;
    case &quot;number&quot;: sfmt = (o.table != null ? o.table : table_fmt)[fmt]; break;
  }</code></pre>
<p>LibreOffice appears to emit the format “GENERAL” for general:</p>
<pre><code>  if(isgeneral(sfmt,0)) return general_fmt(v, o);
  var f = choose_fmt(sfmt, v);
  if(isgeneral(f[1])) return general_fmt(v, o);</code></pre>
<p>The boolean TRUE and FALSE are formatted as if they are the uppercase text:</p>
<pre><code>  if(v === true) v = &quot;TRUE&quot;; else if(v === false) v = &quot;FALSE&quot;;</code></pre>
<p>Empty string should always emit empty, even if there are other characters:</p>
<pre><code>  else if(v === &quot;&quot; || v == null) return &quot;&quot;;
  return eval_fmt(f[1], v, o, f[0]);
}</code></pre>
<p>The methods beginning with an underscore are subject to change and should not be used directly in programs.</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode js&gt;tmp/98_exports.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb109-1" title="1"><span class="va">SSF</span>.<span class="at">_table</span> <span class="op">=</span> table_fmt<span class="op">;</span></a>
<a class="sourceLine" id="cb109-2" title="2"><span class="va">SSF</span>.<span class="at">load</span> <span class="op">=</span> <span class="kw">function</span> <span class="at">load_entry</span>(fmt<span class="op">,</span> idx) <span class="op">{</span> table_fmt[idx] <span class="op">=</span> fmt<span class="op">;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb109-3" title="3"><span class="va">SSF</span>.<span class="at">format</span> <span class="op">=</span> format<span class="op">;</span></a></code></pre></div>
<p>To support multiple SSF tables:</p>
<pre><code>SSF.get_table = function get_table() { return table_fmt; };
SSF.load_table = function load_table(tbl) { for(var i=0; i!=0x0188; ++i) if(tbl[i] !== undefined) SSF.load(tbl[i], i); };</code></pre>
<h2 id="fraction-library">Fraction Library</h2>
<p>The implementation is from <a href="https://github.com/SheetJS/frac/">our frac library</a>:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode js&gt;tmp/30_frac.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb111-1" title="1"><span class="kw">function</span> <span class="at">frac</span>(x<span class="op">,</span> D<span class="op">,</span> mixed) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-2" title="2">  <span class="kw">var</span> sgn <span class="op">=</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">-1</span> : <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-3" title="3">  <span class="kw">var</span> B <span class="op">=</span> x <span class="op">*</span> sgn<span class="op">;</span></a>
<a class="sourceLine" id="cb111-4" title="4">  <span class="kw">var</span> P_2 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> P_1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> P <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-5" title="5">  <span class="kw">var</span> Q_2 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> Q_1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> Q <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-6" title="6">  <span class="kw">var</span> A <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(B)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-7" title="7">  <span class="cf">while</span>(Q_1 <span class="op">&lt;</span> D) <span class="op">{</span></a>
<a class="sourceLine" id="cb111-8" title="8">    A <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(B)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-9" title="9">    P <span class="op">=</span> A <span class="op">*</span> P_1 <span class="op">+</span> P_2<span class="op">;</span></a>
<a class="sourceLine" id="cb111-10" title="10">    Q <span class="op">=</span> A <span class="op">*</span> Q_1 <span class="op">+</span> Q_2<span class="op">;</span></a>
<a class="sourceLine" id="cb111-11" title="11">    <span class="cf">if</span>((B <span class="op">-</span> A) <span class="op">&lt;</span> <span class="fl">0.0000000005</span>) <span class="cf">break</span><span class="op">;</span></a>
<a class="sourceLine" id="cb111-12" title="12">    B <span class="op">=</span> <span class="dv">1</span> / (B <span class="op">-</span> A)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-13" title="13">    P_2 <span class="op">=</span> P_1<span class="op">;</span> P_1 <span class="op">=</span> P<span class="op">;</span></a>
<a class="sourceLine" id="cb111-14" title="14">    Q_2 <span class="op">=</span> Q_1<span class="op">;</span> Q_1 <span class="op">=</span> Q<span class="op">;</span></a>
<a class="sourceLine" id="cb111-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb111-16" title="16">  <span class="cf">if</span>(Q <span class="op">&gt;</span> D) <span class="op">{</span> Q <span class="op">=</span> Q_1<span class="op">;</span> P <span class="op">=</span> P_1<span class="op">;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb111-17" title="17">  <span class="cf">if</span>(Q <span class="op">&gt;</span> D) <span class="op">{</span> Q <span class="op">=</span> Q_2<span class="op">;</span> P <span class="op">=</span> P_2<span class="op">;</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb111-18" title="18">  <span class="cf">if</span>(<span class="op">!</span>mixed) <span class="cf">return</span> [<span class="dv">0</span><span class="op">,</span> sgn <span class="op">*</span> P<span class="op">,</span> Q]<span class="op">;</span></a>
<a class="sourceLine" id="cb111-19" title="19">  <span class="cf">if</span>(Q<span class="op">===</span><span class="dv">0</span>) <span class="cf">throw</span> <span class="st">&quot;Unexpected state: &quot;</span><span class="op">+</span>P<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>P_1<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>P_2<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>Q<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>Q_1<span class="op">+</span><span class="st">&quot; &quot;</span><span class="op">+</span>Q_2<span class="op">;</span></a>
<a class="sourceLine" id="cb111-20" title="20">  <span class="kw">var</span> q <span class="op">=</span> <span class="va">Math</span>.<span class="at">floor</span>(sgn <span class="op">*</span> P/Q)<span class="op">;</span></a>
<a class="sourceLine" id="cb111-21" title="21">  <span class="cf">return</span> [q<span class="op">,</span> sgn<span class="op">*</span>P <span class="op">-</span> q<span class="op">*</span>Q<span class="op">,</span> Q]<span class="op">;</span></a>
<a class="sourceLine" id="cb111-22" title="22"><span class="op">}</span></a></code></pre></div>
<h2 id="js-boilerplate">JS Boilerplate</h2>
<div class="sourceCode" id="cb112"><pre class="sourceCode js&gt;tmp/00_header.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb112-1" title="1"><span class="co">/* ssf.js (C) 2013-2014 SheetJS -- http://sheetjs.com */</span></a>
<a class="sourceLine" id="cb112-2" title="2"><span class="co">/*jshint -W041 */</span></a>
<a class="sourceLine" id="cb112-3" title="3"><span class="kw">var</span> SSF <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb112-4" title="4"><span class="kw">var</span> make_ssf <span class="op">=</span> <span class="kw">function</span> <span class="at">make_ssf</span>(SSF)<span class="op">{</span></a></code></pre></div>
<div class="sourceCode" id="cb113"><pre class="sourceCode js&gt;tmp/99_footer.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb113-1" title="1">}<span class="op">;</span></a>
<a class="sourceLine" id="cb113-2" title="2"><span class="at">make_ssf</span>(SSF)<span class="op">;</span></a>
<a class="sourceLine" id="cb113-3" title="3"><span class="cf">if</span>(<span class="kw">typeof</span> module <span class="op">!==</span> <span class="st">&#39;undefined&#39;</span> <span class="op">&amp;&amp;</span> <span class="kw">typeof</span> DO_NOT_EXPORT_SSF <span class="op">===</span> <span class="st">&#39;undefined&#39;</span>) <span class="va">module</span>.<span class="at">exports</span> <span class="op">=</span> SSF<span class="op">;</span></a></code></pre></div>
<h2 id="vocrc-and-post-commands">.vocrc and post-commands</h2>
<div class="sourceCode" id="cb114"><pre class="sourceCode bash&gt;tmp/post.sh"><code class="sourceCode bash"><a class="sourceLine" id="cb114-1" title="1"><span class="co">#!/bin/bash</span></a>
<a class="sourceLine" id="cb114-2" title="2"><span class="ex">npm</span> install</a>
<a class="sourceLine" id="cb114-3" title="3"><span class="bu">echo</span> <span class="st">&quot;SSF.version = &#39;&quot;</span><span class="kw">`</span><span class="fu">grep</span> version package.json <span class="kw">|</span> <span class="fu">awk</span> <span class="st">&#39;{gsub(/[^0-9\.]/,&quot;&quot;,$2); print $2}&#39;</span><span class="kw">`</span><span class="st">&quot;&#39;;&quot;</span> <span class="op">&gt;</span> tmp/01_version.js</a>
<a class="sourceLine" id="cb114-4" title="4"><span class="fu">cat</span> tmp/*.js <span class="op">&gt;</span> ssf.js</a></code></pre></div>
<pre class="json&gt;.vocrc"><code>{
  &quot;post&quot;: &quot;bash tmp/post.sh&quot;
}</code></pre>
<pre class="&gt;.gitignore"><code>node_modules/
tmp/
.vocrc
v8.log
perf.log</code></pre>
<pre class="&gt;.npmignore"><code>test/
misc/
node_modules/
tmp/
Makefile
ssf.md
index.html
.gitignore
.vocrc
.jscs.json
.travis.yml
v8.log
perf.log</code></pre>
<pre class="make&gt;makefile"><code>.PHONY: test ssf
ssf: ssf.md
        voc ssf.md

test:
        npm test

test_min:
        MINTEST=1 npm test

.PHONY: lint
lint:
        jshint ssf.js test/
        jscs ssf.js

.PHONY: perf
perf:
        bash misc/perf.sh</code></pre>
<p>Coverage tests use <a href="http://npm.im/blanket">blanket</a>:</p>
<pre><code>
.PHONY: cov
cov: tmp/coverage.html

tmp/coverage.html: ssf
        mocha --require blanket -R html-cov &gt; tmp/coverage.html

.PHONY: cov_min
cov_min:
        MINTEST=1 make cov</code></pre>
<p>Coveralls.io support</p>
<pre><code>
.PHONY: coveralls full_coveralls
full_coveralls:
        mocha --require blanket --reporter mocha-lcov-reporter | ./node_modules/coveralls/bin/coveralls.js

coveralls:
        MINTEST=1 make full_coveralls
</code></pre>
<div class="sourceCode" id="cb121"><pre class="sourceCode json&gt;package.json"><code class="sourceCode json"><a class="sourceLine" id="cb121-1" title="1"><span class="fu">{</span></a>
<a class="sourceLine" id="cb121-2" title="2">  <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;ssf&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-3" title="3">  <span class="dt">&quot;version&quot;</span><span class="fu">:</span> <span class="st">&quot;0.8.2&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-4" title="4">  <span class="dt">&quot;author&quot;</span><span class="fu">:</span> <span class="st">&quot;SheetJS&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-5" title="5">  <span class="dt">&quot;description&quot;</span><span class="fu">:</span> <span class="st">&quot;Format data using ECMA-376 spreadsheet Format Codes&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-6" title="6">  <span class="dt">&quot;keywords&quot;</span><span class="fu">:</span> <span class="ot">[</span> <span class="st">&quot;format&quot;</span><span class="ot">,</span> <span class="st">&quot;sprintf&quot;</span><span class="ot">,</span> <span class="st">&quot;spreadsheet&quot;</span> <span class="ot">]</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-7" title="7">  <span class="dt">&quot;bin&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-8" title="8">    <span class="dt">&quot;ssf&quot;</span><span class="fu">:</span> <span class="st">&quot;./bin/ssf.njs&quot;</span></a>
<a class="sourceLine" id="cb121-9" title="9">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-10" title="10">  <span class="dt">&quot;main&quot;</span><span class="fu">:</span> <span class="st">&quot;ssf.js&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-11" title="11">  <span class="dt">&quot;dependencies&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-12" title="12">    <span class="dt">&quot;voc&quot;</span><span class="fu">:</span><span class="st">&quot;&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-13" title="13">    <span class="dt">&quot;colors&quot;</span><span class="fu">:</span><span class="st">&quot;0.6.2&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-14" title="14">    <span class="dt">&quot;frac&quot;</span><span class="fu">:</span><span class="st">&quot;0.3.1&quot;</span></a>
<a class="sourceLine" id="cb121-15" title="15">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-16" title="16">  <span class="dt">&quot;devDependencies&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-17" title="17">    <span class="dt">&quot;mocha&quot;</span><span class="fu">:</span><span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb121-18" title="18">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-19" title="19">  <span class="dt">&quot;repository&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;type&quot;</span><span class="fu">:</span><span class="st">&quot;git&quot;</span><span class="fu">,</span> <span class="dt">&quot;url&quot;</span><span class="fu">:</span><span class="st">&quot;git://github.com/SheetJS/ssf.git&quot;</span> <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-20" title="20">  <span class="dt">&quot;scripts&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-21" title="21">    <span class="dt">&quot;test&quot;</span><span class="fu">:</span> <span class="st">&quot;mocha -R spec&quot;</span></a>
<a class="sourceLine" id="cb121-22" title="22">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-23" title="23">  <span class="dt">&quot;config&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-24" title="24">    <span class="dt">&quot;blanket&quot;</span><span class="fu">:</span> <span class="fu">{</span></a>
<a class="sourceLine" id="cb121-25" title="25">      <span class="dt">&quot;pattern&quot;</span><span class="fu">:</span> <span class="st">&quot;ssf.js&quot;</span></a>
<a class="sourceLine" id="cb121-26" title="26">    <span class="fu">}</span></a>
<a class="sourceLine" id="cb121-27" title="27">  <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-28" title="28">  <span class="dt">&quot;bugs&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;url&quot;</span><span class="fu">:</span> <span class="st">&quot;https://github.com/SheetJS/ssf/issues&quot;</span> <span class="fu">},</span></a>
<a class="sourceLine" id="cb121-29" title="29">  <span class="dt">&quot;license&quot;</span><span class="fu">:</span> <span class="st">&quot;Apache-2.0&quot;</span><span class="fu">,</span></a>
<a class="sourceLine" id="cb121-30" title="30">  <span class="dt">&quot;engines&quot;</span><span class="fu">:</span> <span class="fu">{</span> <span class="dt">&quot;node&quot;</span><span class="fu">:</span> <span class="st">&quot;&gt;=0.8&quot;</span> <span class="fu">}</span></a>
<a class="sourceLine" id="cb121-31" title="31"><span class="fu">}</span></a></code></pre></div>
<h1 id="test-driver">Test Driver</h1>
<p>Travis CI is used for node testing:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode &gt;.travis.yml"><code class="sourceCode yaml"><a class="sourceLine" id="cb122-1" title="1"><span class="fu">language:</span><span class="at"> node_js</span></a>
<a class="sourceLine" id="cb122-2" title="2"><span class="fu">node_js:</span></a>
<a class="sourceLine" id="cb122-3" title="3">  <span class="kw">-</span> <span class="st">&quot;0.11&quot;</span></a>
<a class="sourceLine" id="cb122-4" title="4">  <span class="kw">-</span> <span class="st">&quot;0.10&quot;</span></a>
<a class="sourceLine" id="cb122-5" title="5">  <span class="kw">-</span> <span class="st">&quot;0.8&quot;</span></a>
<a class="sourceLine" id="cb122-6" title="6"><span class="fu">before_install:</span></a>
<a class="sourceLine" id="cb122-7" title="7">  <span class="kw">-</span> <span class="st">&quot;npm install -g mocha&quot;</span></a>
<a class="sourceLine" id="cb122-8" title="8">  <span class="kw">-</span> <span class="st">&quot;npm install blanket&quot;</span></a>
<a class="sourceLine" id="cb122-9" title="9">  <span class="kw">-</span> <span class="st">&quot;npm install coveralls mocha-lcov-reporter&quot;</span></a>
<a class="sourceLine" id="cb122-10" title="10"><span class="fu">after_success:</span></a>
<a class="sourceLine" id="cb122-11" title="11">  <span class="kw">-</span> <span class="st">&quot;make coveralls&quot;</span></a></code></pre></div>
<p>The mocha test driver tests the implied formats:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode js&gt;test/implied.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb123-1" title="1"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-2" title="2"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-3" title="3"><span class="kw">var</span> data <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/implied.json&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb123-4" title="4"><span class="kw">var</span> skip <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb123-5" title="5"><span class="kw">function</span> <span class="at">doit</span>(d) <span class="op">{</span></a>
<a class="sourceLine" id="cb123-6" title="6">  d[<span class="dv">1</span>].<span class="at">forEach</span>(<span class="kw">function</span>(r)<span class="op">{</span><span class="cf">if</span>(<span class="va">r</span>.<span class="at">length</span> <span class="op">===</span> <span class="dv">2</span>)<span class="va">assert</span>.<span class="at">equal</span>(<span class="va">SSF</span>.<span class="at">format</span>(r[<span class="dv">0</span>]<span class="op">,</span>d[<span class="dv">0</span>])<span class="op">,</span>r[<span class="dv">1</span>])<span class="op">;}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb123-8" title="8"><span class="at">describe</span>(<span class="st">&#39;implied formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb123-9" title="9">  <span class="va">data</span>.<span class="at">forEach</span>(<span class="kw">function</span>(d) <span class="op">{</span></a>
<a class="sourceLine" id="cb123-10" title="10">    <span class="cf">if</span>(<span class="va">d</span>.<span class="at">length</span> <span class="op">==</span> <span class="dv">2</span>) <span class="at">it</span>(d[<span class="dv">0</span>]<span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span> <span class="at">doit</span>(d)<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-11" title="11">    <span class="cf">else</span> <span class="at">it</span>(d[<span class="dv">1</span>]<span class="op">+</span><span class="st">&quot; for &quot;</span><span class="op">+</span>d[<span class="dv">0</span>]<span class="op">,</span> <span class="va">skip</span>.<span class="at">indexOf</span>(d[<span class="dv">1</span>]) <span class="op">&gt;</span> <span class="dv">-1</span> <span class="op">?</span> <span class="kw">null</span> : <span class="kw">function</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb123-12" title="12">      <span class="va">assert</span>.<span class="at">equal</span>(<span class="va">SSF</span>.<span class="at">format</span>(d[<span class="dv">1</span>]<span class="op">,</span> d[<span class="dv">0</span>]<span class="op">,</span> <span class="op">{}</span>)<span class="op">,</span> d[<span class="dv">2</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb123-13" title="13">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-14" title="14">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb123-15" title="15"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The general test driver tests the General format:</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode js&gt;test/general.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb124-1" title="1"><span class="co">/* vim: set ts=2: */</span></a>
<a class="sourceLine" id="cb124-2" title="2"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-3" title="3"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-4" title="4"><span class="kw">var</span> data <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/general.json&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb124-5" title="5"><span class="kw">var</span> skip <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb124-6" title="6"><span class="at">describe</span>(<span class="st">&#39;General format&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb124-7" title="7">  <span class="va">data</span>.<span class="at">forEach</span>(<span class="kw">function</span>(d) <span class="op">{</span></a>
<a class="sourceLine" id="cb124-8" title="8">    <span class="at">it</span>(d[<span class="dv">1</span>]<span class="op">+</span><span class="st">&quot; for &quot;</span><span class="op">+</span>d[<span class="dv">0</span>]<span class="op">,</span> <span class="va">skip</span>.<span class="at">indexOf</span>(d[<span class="dv">1</span>]) <span class="op">&gt;</span> <span class="dv">-1</span> <span class="op">?</span> <span class="kw">null</span> : <span class="kw">function</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb124-9" title="9">      <span class="va">assert</span>.<span class="at">equal</span>(<span class="va">SSF</span>.<span class="at">format</span>(d[<span class="dv">1</span>]<span class="op">,</span> d[<span class="dv">0</span>]<span class="op">,</span> <span class="op">{}</span>)<span class="op">,</span> d[<span class="dv">2</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb124-10" title="10">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-11" title="11">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-12" title="12">  <span class="at">it</span>(<span class="st">&#39;should fail for undefined and null&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb124-13" title="13">    <span class="va">assert</span>.<span class="at">throws</span>(<span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb124-14" title="14">      <span class="va">SSF</span>.<span class="at">format</span>(<span class="st">&quot;General&quot;</span><span class="op">,</span> <span class="kw">undefined</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-15" title="15">      <span class="va">SSF</span>.<span class="at">format</span>(<span class="st">&quot;General&quot;</span><span class="op">,</span> <span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-16" title="16">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-17" title="17">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb124-18" title="18"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The fraction test driver tests fractional formats:</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode js&gt;test/fraction.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb125-1" title="1"><span class="co">/* vim: set ts=2: */</span></a>
<a class="sourceLine" id="cb125-2" title="2"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-3" title="3"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-4" title="4"><span class="kw">var</span> data <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/fraction.json&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb125-5" title="5"><span class="kw">var</span> skip <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb125-6" title="6"><span class="at">describe</span>(<span class="st">&#39;fractional formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb125-7" title="7">  <span class="va">data</span>.<span class="at">forEach</span>(<span class="kw">function</span>(d) <span class="op">{</span></a>
<a class="sourceLine" id="cb125-8" title="8">    <span class="at">it</span>(d[<span class="dv">1</span>]<span class="op">+</span><span class="st">&quot; for &quot;</span><span class="op">+</span>d[<span class="dv">0</span>]<span class="op">,</span> <span class="va">skip</span>.<span class="at">indexOf</span>(d[<span class="dv">1</span>]) <span class="op">&gt;</span> <span class="dv">-1</span> <span class="op">?</span> <span class="kw">null</span> : <span class="kw">function</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb125-9" title="9">      <span class="kw">var</span> expected <span class="op">=</span> d[<span class="dv">2</span>]<span class="op">,</span> actual <span class="op">=</span> <span class="va">SSF</span>.<span class="at">format</span>(d[<span class="dv">1</span>]<span class="op">,</span> d[<span class="dv">0</span>]<span class="op">,</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-10" title="10">      <span class="co">//var r = actual.match(/(-?)\d* *\d+\/\d+/);</span></a>
<a class="sourceLine" id="cb125-11" title="11">      <span class="va">assert</span>.<span class="at">equal</span>(actual<span class="op">,</span> expected)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-12" title="12">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-13" title="13">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb125-14" title="14"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The dates test driver tests the date and time formats:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode js&gt;test/date.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb126-1" title="1"><span class="co">/* vim: set ts=2: */</span></a>
<a class="sourceLine" id="cb126-2" title="2"><span class="co">/*jshint -W041 */</span></a>
<a class="sourceLine" id="cb126-3" title="3"><span class="co">/*jshint loopfunc:true */</span></a>
<a class="sourceLine" id="cb126-4" title="4"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-5" title="5"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-6" title="6"><span class="kw">var</span> dates <span class="op">=</span> <span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/dates.tsv&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-7" title="7"><span class="kw">var</span> date2 <span class="op">=</span> <span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/cal.tsv&#39;</span><span class="op">,</span>  <span class="st">&#39;utf8&#39;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-8" title="8"><span class="kw">var</span> times <span class="op">=</span> <span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/times.tsv&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-9" title="9"><span class="kw">function</span> <span class="at">doit</span>(data) <span class="op">{</span></a>
<a class="sourceLine" id="cb126-10" title="10">  <span class="kw">var</span> step <span class="op">=</span> <span class="va">Math</span>.<span class="at">ceil</span>(<span class="va">data</span>.<span class="at">length</span>/<span class="dv">100</span>)<span class="op">,</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb126-11" title="11">  <span class="kw">var</span> headers <span class="op">=</span> data[<span class="dv">0</span>].<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-12" title="12">  <span class="cf">for</span>(j<span class="op">=</span><span class="dv">0</span><span class="op">;</span>j<span class="op">&lt;=</span><span class="dv">100</span><span class="op">;++</span>j) <span class="at">it</span>(j<span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb126-13" title="13">    <span class="cf">for</span>(<span class="kw">var</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;=</span> step<span class="op">;</span> <span class="op">++</span>k<span class="op">,++</span>i) <span class="op">{</span></a>
<a class="sourceLine" id="cb126-14" title="14">      <span class="cf">if</span>(data[i] <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> data[i].<span class="at">length</span> <span class="op">&lt;</span> <span class="dv">3</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb126-15" title="15">      <span class="kw">var</span> d <span class="op">=</span> data[i].<span class="at">replace</span>(<span class="ss">/#</span><span class="sc">{255}</span><span class="ss">/g</span><span class="op">,</span><span class="st">&quot;&quot;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-16" title="16">      <span class="cf">for</span>(<span class="kw">var</span> w <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> w <span class="op">&lt;</span> <span class="va">headers</span>.<span class="at">length</span><span class="op">;</span> <span class="op">++</span>w) <span class="op">{</span></a>
<a class="sourceLine" id="cb126-17" title="17">        <span class="kw">var</span> expected <span class="op">=</span> d[w]<span class="op">,</span> actual <span class="op">=</span> <span class="va">SSF</span>.<span class="at">format</span>(headers[w]<span class="op">,</span> <span class="at">parseFloat</span>(d[<span class="dv">0</span>])<span class="op">,</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-18" title="18">        <span class="cf">if</span>(actual <span class="op">!=</span> expected) <span class="cf">throw</span> [actual<span class="op">,</span> expected<span class="op">,</span> w<span class="op">,</span> headers[w]<span class="op">,</span>d[<span class="dv">0</span>]<span class="op">,</span>d<span class="op">,</span>i].<span class="at">join</span>(<span class="st">&quot;|&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-19" title="19">        actual <span class="op">=</span> <span class="va">SSF</span>.<span class="at">format</span>(headers[w].<span class="at">toUpperCase</span>()<span class="op">,</span> <span class="at">parseFloat</span>(d[<span class="dv">0</span>])<span class="op">,</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-20" title="20">        <span class="cf">if</span>(actual <span class="op">!=</span> expected) <span class="cf">throw</span> [actual<span class="op">,</span> expected<span class="op">,</span> w<span class="op">,</span> headers[w].<span class="at">toUpperCase</span>()<span class="op">,</span>d[<span class="dv">0</span>]<span class="op">,</span>d<span class="op">,</span>i].<span class="at">join</span>(<span class="st">&quot;|&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-21" title="21">      <span class="op">}</span></a>
<a class="sourceLine" id="cb126-22" title="22">    <span class="op">}</span></a>
<a class="sourceLine" id="cb126-23" title="23">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-24" title="24"><span class="op">}</span></a>
<a class="sourceLine" id="cb126-25" title="25"><span class="at">describe</span>(<span class="st">&#39;time formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb126-26" title="26">  <span class="at">doit</span>(<span class="va">process</span>.<span class="va">env</span>.<span class="at">MINTEST</span> <span class="op">?</span> <span class="va">times</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span><span class="dv">4000</span>) : times)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-27" title="27"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-28" title="28"><span class="at">describe</span>(<span class="st">&#39;date formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb126-29" title="29">  <span class="at">doit</span>(<span class="va">process</span>.<span class="va">env</span>.<span class="at">MINTEST</span> <span class="op">?</span> <span class="va">dates</span>.<span class="at">slice</span>(<span class="dv">0</span><span class="op">,</span><span class="dv">4000</span>) : dates)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-30" title="30">  <span class="co">//doit(process.env.MINTEST ? date2.slice(0,1000) : date2);</span></a>
<a class="sourceLine" id="cb126-31" title="31">  <span class="at">it</span>(<span class="st">&#39;should fail for bad formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb126-32" title="32">    <span class="kw">var</span> bad <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb126-33" title="33">    <span class="kw">var</span> chk <span class="op">=</span> <span class="kw">function</span>(fmt)<span class="op">{</span> <span class="cf">return</span> <span class="kw">function</span>()<span class="op">{</span> <span class="va">SSF</span>.<span class="at">format</span>(fmt<span class="op">,</span><span class="dv">0</span>)<span class="op">;</span> <span class="op">};</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb126-34" title="34">    <span class="va">bad</span>.<span class="at">forEach</span>(<span class="kw">function</span>(fmt)<span class="op">{</span><span class="va">assert</span>.<span class="at">throws</span>(<span class="at">chk</span>(fmt))<span class="op">;}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-35" title="35">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb126-36" title="36"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The exponential test driver tests exponential formats (pipe denotes fails)</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode js&gt;test/exp.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb127-1" title="1"><span class="co">/* vim: set ts=2: */</span></a>
<a class="sourceLine" id="cb127-2" title="2"><span class="co">/*jshint loopfunc:true */</span></a>
<a class="sourceLine" id="cb127-3" title="3"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-4" title="4"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-5" title="5"><span class="kw">var</span> data <span class="op">=</span> <span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/exp.tsv&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-6" title="6"><span class="kw">function</span> <span class="at">doit</span>(d<span class="op">,</span> headers) <span class="op">{</span></a>
<a class="sourceLine" id="cb127-7" title="7">  <span class="at">it</span>(d[<span class="dv">0</span>]<span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb127-8" title="8">    <span class="cf">for</span>(<span class="kw">var</span> w <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> w <span class="op">&lt;</span> <span class="va">headers</span>.<span class="at">length</span><span class="op">;</span> <span class="op">++</span>w) <span class="op">{</span></a>
<a class="sourceLine" id="cb127-9" title="9">      <span class="kw">var</span> expected <span class="op">=</span> d[w].<span class="at">replace</span>(<span class="st">&quot;|&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span>)<span class="op">,</span> actual<span class="op">;</span></a>
<a class="sourceLine" id="cb127-10" title="10">      <span class="cf">try</span> <span class="op">{</span> actual <span class="op">=</span> <span class="va">SSF</span>.<span class="at">format</span>(headers[w]<span class="op">,</span> <span class="at">parseFloat</span>(d[<span class="dv">0</span>])<span class="op">,</span> <span class="op">{}</span>)<span class="op">;</span> <span class="op">}</span> <span class="cf">catch</span>(e) <span class="op">{</span> <span class="op">}</span></a>
<a class="sourceLine" id="cb127-11" title="11">      <span class="cf">if</span>(actual <span class="op">!=</span> expected <span class="op">&amp;&amp;</span> d[w][<span class="dv">0</span>] <span class="op">!==</span> <span class="st">&quot;|&quot;</span>) <span class="cf">throw</span> [actual<span class="op">,</span> expected<span class="op">,</span> w<span class="op">,</span> headers[w]<span class="op">,</span>d[<span class="dv">0</span>]<span class="op">,</span>d].<span class="at">join</span>(<span class="st">&quot;|&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-12" title="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb127-13" title="13">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-14" title="14"><span class="op">}</span></a>
<a class="sourceLine" id="cb127-15" title="15"><span class="at">describe</span>(<span class="st">&#39;exponential formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb127-16" title="16">  <span class="kw">var</span> headers <span class="op">=</span> data[<span class="dv">0</span>].<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-17" title="17">  <span class="cf">for</span>(<span class="kw">var</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;</span><span class="va">data</span>.<span class="at">length</span><span class="op">;++</span>j) <span class="op">{</span></a>
<a class="sourceLine" id="cb127-18" title="18">    <span class="cf">if</span>(<span class="op">!</span>data[j]) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb127-19" title="19">    <span class="at">doit</span>(data[j].<span class="at">replace</span>(<span class="ss">/#</span><span class="sc">{255}</span><span class="ss">/g</span><span class="op">,</span><span class="st">&quot;&quot;</span>).<span class="at">split</span>(<span class="st">&quot;</span><span class="sc">\t</span><span class="st">&quot;</span>)<span class="op">,</span> headers)<span class="op">;</span></a>
<a class="sourceLine" id="cb127-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb127-21" title="21"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>The oddities test driver tests random odd formats</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode js&gt;test/oddities.js"><code class="sourceCode javascript"><a class="sourceLine" id="cb128-1" title="1"><span class="co">/* vim: set ts=2: */</span></a>
<a class="sourceLine" id="cb128-2" title="2"><span class="co">/*jshint loopfunc:true */</span></a>
<a class="sourceLine" id="cb128-3" title="3"><span class="kw">var</span> SSF <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;../&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-4" title="4"><span class="kw">var</span> fs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;fs&#39;</span>)<span class="op">,</span> assert <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;assert&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-5" title="5"><span class="kw">var</span> data <span class="op">=</span> <span class="va">JSON</span>.<span class="at">parse</span>(<span class="va">fs</span>.<span class="at">readFileSync</span>(<span class="st">&#39;./test/oddities.json&#39;</span><span class="op">,</span><span class="st">&#39;utf8&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb128-6" title="6"><span class="at">describe</span>(<span class="st">&#39;oddities&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb128-7" title="7">  <span class="va">data</span>.<span class="at">forEach</span>(<span class="kw">function</span>(d) <span class="op">{</span></a>
<a class="sourceLine" id="cb128-8" title="8">    <span class="at">it</span>(d[<span class="dv">0</span>]<span class="op">,</span> <span class="kw">function</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb128-9" title="9">      <span class="cf">for</span>(<span class="kw">var</span> j<span class="op">=</span><span class="dv">1</span><span class="op">;</span>j<span class="op">&lt;</span><span class="va">d</span>.<span class="at">length</span><span class="op">;++</span>j) <span class="op">{</span></a>
<a class="sourceLine" id="cb128-10" title="10">        <span class="cf">if</span>(d[j].<span class="at">length</span> <span class="op">==</span> <span class="dv">2</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb128-11" title="11">          <span class="kw">var</span> expected <span class="op">=</span> d[j][<span class="dv">1</span>]<span class="op">,</span> actual <span class="op">=</span> <span class="va">SSF</span>.<span class="at">format</span>(d[<span class="dv">0</span>]<span class="op">,</span> d[j][<span class="dv">0</span>]<span class="op">,</span> <span class="op">{}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-12" title="12">          <span class="va">assert</span>.<span class="at">equal</span>(actual<span class="op">,</span> expected)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-13" title="13">        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span>(d[j][<span class="dv">2</span>] <span class="op">!==</span> <span class="st">&quot;#&quot;</span>) <span class="va">assert</span>.<span class="at">throws</span>(<span class="kw">function</span>() <span class="op">{</span> <span class="va">SSF</span>.<span class="at">format</span>(d[<span class="dv">0</span>]<span class="op">,</span> d[j][<span class="dv">0</span>])<span class="op">;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-14" title="14">      <span class="op">}</span></a>
<a class="sourceLine" id="cb128-15" title="15">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-16" title="16">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-17" title="17">  <span class="at">it</span>(<span class="st">&#39;should fail for bad formats&#39;</span><span class="op">,</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb128-18" title="18">    <span class="kw">var</span> bad <span class="op">=</span> [<span class="st">&#39;##,##&#39;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb128-19" title="19">    <span class="kw">var</span> chk <span class="op">=</span> <span class="kw">function</span>(fmt)<span class="op">{</span> <span class="cf">return</span> <span class="kw">function</span>()<span class="op">{</span> <span class="va">SSF</span>.<span class="at">format</span>(fmt<span class="op">,</span><span class="dv">0</span>)<span class="op">;</span> <span class="op">};</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb128-20" title="20">    <span class="va">bad</span>.<span class="at">forEach</span>(<span class="kw">function</span>(fmt)<span class="op">{</span><span class="va">assert</span>.<span class="at">throws</span>(<span class="at">chk</span>(fmt))<span class="op">;}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-21" title="21">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb128-22" title="22"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<h1 id="license">LICENSE</h1>
<pre class="&gt;license"><code>Copyright (C) 2013-2014   SheetJS

   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.</code></pre>
